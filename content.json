{"meta":{"title":"Robin's blogs","subtitle":"每天进步一点，从小白到大师","description":"越过高山，遇见更好的自己","author":"Robin Zhang","url":"/localhost:4000"},"pages":[{"title":"About me","date":"2015-02-05T12:03:48.000Z","updated":"2018-02-08T07:25:35.000Z","comments":false,"path":"about/index.html","permalink":"/localhost:4000/about/index.html","excerpt":"","text":"基本资料 职业：前端工程师爱好：UE,UI,FE,VR,music,climbing,etc工作地址：杭州市江干区卓建科技联系方式：1484054651@qq.com,187***01**5 微信"},{"title":"categories","date":"2016-12-05T10:17:44.000Z","updated":"2018-02-08T07:19:07.675Z","comments":false,"path":"categories/index.html","permalink":"/localhost:4000/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-12-05T10:36:51.000Z","updated":"2018-02-07T15:20:09.014Z","comments":false,"path":"tags/index.html","permalink":"/localhost:4000/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"html之iframe标签的基本使用","slug":"html之iframe基本使用","date":"2018-12-12T01:28:00.000Z","updated":"2018-02-10T03:31:38.811Z","comments":true,"path":"html之iframe基本使用/","link":"","permalink":"/localhost:4000/html之iframe基本使用/","excerpt":"如果你的页面是一个后台管理页面，那么你一定对iframe不陌生。从h5定稿开始，在涉及框架引入页面时，统一建议使用iframe来进行相关的资源嵌入。","text":"如果你的页面是一个后台管理页面，那么你一定对iframe不陌生。从h5定稿开始，在涉及框架引入页面时，统一建议使用iframe来进行相关的资源嵌入。 使用场景 通常在不希望整体页面跳转，只需要主体页面跳转，则需要加入iframe标签来作为展示页面的窗口，通常在管理后台 、qq邮箱等管理界面应用比较多。 iframe 的属性中有src以及name属性 ，通过这两个属性可以搭配a标签实现第一条的需求，name是a连接target属性的指向地址，而src的地址可以通过a的href来改变 基本属性 src 属性 指向该框架链接的页面地址，可以为相对请求地址，也可以为绝对地址，也可以为外网地址，当为不同服务器项目涉及跨域时，控制台会报错，但不会影响正常的显示 name 大多数标签都有的自带属性，在input中为特殊含义 指代数据项的类型，而在iframe中可以用来当做目标 frameborder 框架的边框可以用cssborder 代替 width 一般由展示的空间决定宽度 ，height一般由载入页面的高度确定 scrolling :auto yes no ,也可以用css 的overflow 的相关属性来控制 iframe获取子页面的高度 通常用于正确设置嵌入页的高度，一般情况下要设置展示嵌入页为固定大小的。12345678910111213141516171819//父页面载入获取高度 标签内事件 ： onload=\"this.height=this.contentWindow.document.documentElement.scrollHeight\"js脚本通用事件$( \"iframe\").load( function () &#123; $(this).height($(this).contents().find( \"body\" ).height() + 30 );&#125;)//子页面载入之后 改变高度 var htmlHeight=$(\"body\").height()+30;$(\"#iframe\", window.parent.document).height(htmlHeight);``` ## 父子页面元素的获取* 父页面以及子页面位置的元素获取``` javascript // 父页面获取子页面的元素 $(\"#iframe\").contents().find(\"#body\") //子页面获取父页面的元素$(window.parent.document).find(\"#iframe\")","categories":[{"name":"html","slug":"html","permalink":"/localhost:4000/categories/html/"}],"tags":[{"name":"iframe","slug":"iframe","permalink":"/localhost:4000/tags/iframe/"}]},{"title":"git版本管理入门（一）","slug":"git入门","date":"2018-02-07T15:20:08.985Z","updated":"2018-02-07T15:20:08.985Z","comments":true,"path":"git入门/","link":"","permalink":"/localhost:4000/git入门/","excerpt":"git版本管理作为开源项目的版本管理法则，以及多分支多版本的扁平分布式支持，被大多数的开发者所喜爱，那么究竟如何才能正确而轻松的学习git的版本管理呢？目前公司内部是搭建的gitlab的平台，那么我们学习gitlab的工作流是必须的哦。","text":"git版本管理作为开源项目的版本管理法则，以及多分支多版本的扁平分布式支持，被大多数的开发者所喜爱，那么究竟如何才能正确而轻松的学习git的版本管理呢？目前公司内部是搭建的gitlab的平台，那么我们学习gitlab的工作流是必须的哦。 准备工作准备一个git源项目 github官网地址 ，也可以选择公司内网的gitlab新建项目， 新建代码仓库教程 本地安装git客户端 软件下载地址：内网地址（win64位） ；官网地址-win 安装教程：点击查看 需要注意的是在进入Configuring the line ending conversions界面，选择换行格式，选择“Checkout as-is, commit Unix-style line endings”（按照检出格式检出，但是提交统一按照unix格式）。其他的都是默认选项点下一步即可。 任意位置，可以在鼠标右键菜单打开git bash,或者用git gui进行相关操作。例如 git –version 可以查看安装好的git版本。除此之外，git bash面板还支持npm相关的命令操作，但不支持cmd的部分操作。cmd面板可支持git的相关操作，不同的只是前面没有$标志，不影响运行结果。 1$ git --version 图解git git的三个代码仓库 图解git工作流 git常见的三种工作流程 git github flow gitlab flow *了解更多：git三种工作流的区别 git基本配置查看配置1$ git config --list 修改配置 设置用户名，邮箱 12$ git config --global user.name \"csnikey\"$ git config --global user.email \"email address\" 设置编码 123$ git config --global gui.encoding utf-8$ git config --global i18n.commitencoding utf-8$ git config --global i18n.logoutputencoding gbk git基本命令 图解git常用命令行 名词解释: Workspace:工作区 ; Index / Stage：暂存区; Repository：仓库区（或本地仓库）; Remote：远程仓库; 新建项目 当前目录作为项目目录 1$ git init 新建一个目录作为git目录 1$ git init proname 检出一个项目，默认将用远程项目的名字作为项目文件夹名称(如果检出目录已经有该文件，并且非空会报错哦),另外特别说明：默认情况下clone只能检出master分支，检出后可以利用git branch -r 查看远程分支，然后在checkout 对应的远程分支即可（检出时就是检出远程的分支）。 1$ git clone url 检出一个项目，用自定义的名字，会帮你新建文件夹 1$ git clone url self_proname 从远程更新代码 建议项目开发之前都拉取下远程代码 1$ git pull 提交代码到远程 检测本地代码的状态,命令行会给出正确的提交流程 1$ git status 提交代码到暂存区 （.代表 所有文件，也可以指定特定文件）. 1$ git add . 如果遇到提交失败，提示Another git process seems to be running in this repository…,说明有其他进程操作这个文件，删除锁文件即可。然后就可以愉快的进行下一步了。 1$ rm -f ./.git/index.lock 提交代码到本地仓库 （message代表提交的注释，必须填写的） 1$ git commit -m [message] 提交之前从远程拉取项目，更新一下，避免提交失败。如果拉取失败，那么检出有问题的文件，进行处理。 1$ git pull 如果有冲突文件，针对冲突文件进行处理，文件内会有多行冲突描述的，建议使用较好的客户端工具，比如toriseGit 1$ git diff 修改完成之后，重复上面流程，再次pull，如果不报错了，就可以push了，默认提交到本分支 1$ git push 更多清空命令面板1$ clear 相关文档 廖雪峰git教程参考：点击跳转","categories":[{"name":"git","slug":"git","permalink":"/localhost:4000/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"/localhost:4000/tags/git/"}]},{"title":"gulp项目构建入门(2)——基本插件的使用","slug":"gulp入门(2)","date":"2018-02-07T15:20:08.985Z","updated":"2018-02-07T15:20:08.985Z","comments":true,"path":"gulp入门(2)/","link":"","permalink":"/localhost:4000/gulp入门(2)/","excerpt":"如果你已经在项目中引入了gulp，那么不妨尝试用一些gulp集成好的插件来做一些任务。下面假定前端项目中根目录有src以及dist两个，分别用于开发和生产。","text":"如果你已经在项目中引入了gulp，那么不妨尝试用一些gulp集成好的插件来做一些任务。下面假定前端项目中根目录有src以及dist两个，分别用于开发和生产。 前言 以下模块地址均为官网地址，如果觉得请求地址慢，可以访问淘宝镜像的包说明地址，http://npm.taobao.org/ 以下模块介绍顺序不分先后，代码仅供参考，亲测可用。 所有的模块使用都需要require引入，如果下面代码有遗漏请自觉加入。 gulp-less 模块地址：https://www.npmjs.com/package/gulp-less/ 安装 1$ npm install gulp-less --save-dev 使用场景：开发完成之后利用任务自动将开发代码编译 使用123456var less = require('gulp-less');gulp.task('lessCompile', function () &#123; return gulp.src('src/less/style.less') .pipe(less())//less编译 .pipe(gulp.dest('dist/css'));//编译为同名的文件,不需要单独命名样式文件&#125;); gulp-rename 模块地址：https://www.npmjs.com/package/gulp-rename/ 安装 1$ npm install gulp-rename --save-dev 使用场景：区别于开发文件或者追加版本号等，入参有path：子属性有dirname，basename ，prefix，suffix，extname。可以通过字符串，方法以及hash三种方式。个人建议使用最后一个最方便,fn的最强大。 使用1234567891011var rename = require('gulp-rename');gulp.src(\"./src/main/text/hello.txt\", &#123; base: process.cwd() &#125;) //第一种方式 .pipe(rename(&#123; dirname: \"main/text/ciao\", basename: \"aloha\",prefix: \"bonjour-\", suffix: \"-hola\", extname: \".md\"&#125;)) //第二种方式 .pipe(rename(function (path) &#123; path.dirname += \"/ciao\"; path.basename += \"-goodbye\";//支持更灵活的定义 &#125;) gulp-clean-css 模块地址：https://www.npmjs.com/package/gulp-clean-css/ 安装 1$ npm install gulp-clean-css --save-dev 使用场景：导出到生产之前需要压缩样式表配置说明： advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: ‘ie7’,//保留ie7及以下兼容写法 类型：String 默认：’’or’‘ [启用兼容模式； ‘ie7’：IE7兼容模式，’ie8’：IE8兼容模式，’‘：IE9+兼容模式] keepBreaks: true,//类型：Boolean 默认：false [是否保留换行] keepSpecialComments: ‘*’//保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 使用12345var cleanCSS = require('gulp-clean-css');gulp.task('cleanCss', function () &#123; return gulp.src('src/less/style.less') .pipe(cleanCSS())//压缩css文件&#125;); gulp del 模块地址：http://www.gulpjs.com.cn/docs/recipes/delete-files-folder/ 安装 1$ npm install gulp del --save-dev 使用场景：删除指定路径的文件，删除管道中的文件（需要vinylPaths模块的安装），如果是整个文件夹内容清空/.如果是包括文件夹删除，直接文件目录即可，如/**/ 使用12345678var del=require('del'),vinylPaths = require('vinyl-paths')；//删除指定路径的文件gulp.task(\"clean:css\",function(cb)&#123; del(['dist/css/*.css', '!dist/css/*min.css'], cb);&#125;)gulp.task(\"del-less\",function()&#123; return gulp.src('src/less/demo.less') .pipe(vinylPaths(del))&#125;)//删除管道中的文件 gulp-uglify 模块地址：https://www.npmjs.com/package/gulp-uglify 安装 1$ npm install gulp-uglify --save-dev 使用场景：脚本上线之前完成压缩工作 使用12345var uglify = require('gulp-uglify');gulp.task('js', function () &#123; return gulp.src('src/js/*.js') .pipe(uglify())&#125;); gulp-concat 模块地址：https://www.npmjs.com/package/gulp-concat 安装 1$ npm install gulp-concat --save-dev 使用场景：web优化，合并文件减少http请求，同类型的文件才可以合并，比如css可以合并，js可以合并等。 使用12345var fileConcat = require('gulp-concat');gulp.task('fileConcat', function () &#123; return gulp.src('src/js/*.js') .pipe(concat(\"combine.js\"))//可以控制合并生成的文件&#125;); gulp copy 不需要安装任何模块，因为本身gulp的文件流管道机制支持文件拷贝 使用场景：复制相关的文件结构到生产目录，比如页面文件。因为页面文件中的都是相对目录，所以当css以及js使用为产出地址时，要求页面等必备的希望产品的也放到产出目录。 使用12345gulp.task(\"copyhtmldir\",function()&#123; return gulp.src(['src/html/**/*']) .pipe(gulp.dest('dist/html')) &#125;) gulp-imagemin 模块地址：https://www.npmjs.com/package/gulp-imagemin 安装 1$ npm install gulp-imagemin --save-dev 使用场景：上线之前对不必要的高精度图片进行压缩，避免不必要的高清图片。优化加载速度，提升页面性能，配置项为json类型。 optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: true //类型：Boolean 默认：false 多次优化svg直到完全优化 使用12345var imgmin=require(\"gulp-imagemin\");gulp.task(\"imgmin\",function()&#123; return gulp.src('src/images/*') .pipe(imgmin()) .pipe(gulp.dest(\"dist/images\"))&#125;) gulp-autoprefixer 模块地址：https://www.npmjs.com/package/gulp-autoprefixer 安装 1$ npm install gulp-autoprefixer --save-dev 使用场景：不熟悉厂商前缀的开发者可以在开发完成之后利用此模块一次性追加前缀，可以灵活配置前缀需求的浏览器列表。 browsers：[] （定义使用的浏览器版本） cascade ： true （定义对属性进行对齐操作）,默认true remove : true (去掉不必要的前缀) ，默认true 使用12345//直接对管道文件操作 .pipe(autoprefixer(&#123; browsers:[\"last 5 versions\"], cascade:true, remove:true&#125;)) gulp-load-plugins 模块地址：https://www.npmjs.com/package/gulp-load-plugins 安装 1$ npm install gulp-load-plugins --save-dev 使用场景：所有gulp集成的模块插件如果前面有gulp- 开头并且在package.json中有依赖注入，那么不需要重复声明变量，可以直接用$.name使用，后面多单词从第二个词开始首字母需要大写。 使用12345var $ = require('gulp-load-plugins')();$.rename//等效于下面的写法var rename=require('gulp-rename');rename","categories":[{"name":"npm","slug":"npm","permalink":"/localhost:4000/categories/npm/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"/localhost:4000/tags/gulp/"}]},{"title":"gulp项目构建入门(1)","slug":"gulp入门","date":"2018-02-07T15:20:08.985Z","updated":"2018-02-07T15:20:08.985Z","comments":true,"path":"gulp入门/","link":"","permalink":"/localhost:4000/gulp入门/","excerpt":"我们经常会手工作一些代码压缩，文件目录拷贝以及整理的工作，还有一些比如编译以及文件合并，追加前缀等，而这些琐碎的工作实际已经有一个比较好的前端构建工具gulp可以帮我们批量实现。","text":"我们经常会手工作一些代码压缩，文件目录拷贝以及整理的工作，还有一些比如编译以及文件合并，追加前缀等，而这些琐碎的工作实际已经有一个比较好的前端构建工具gulp可以帮我们批量实现。 前言在目前的前端构建或者说自动化中，形成了三足鼎立的情况，分别是百度的fis,grunt,gulp.而无论是用户数还是使用难度，gulp都独占上风，众多的github项目选择了gulp作为构建工具。 gulp的优点 易于使用，通过代码优于配置的策略，让简单的任务简单，复杂的任务可管理。比grunt的使用简单，得到前端开发者的好评。 利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。 插件品质高：Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。 易于学习：通过较少的api，掌握 Gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。 图解gulp工作范畴 官网相关链接 gulp官网： http://www.gulpjs.com.cn/ 入门指南； http://www.gulpjs.com.cn/docs/getting-started/ api文档： http://www.gulpjs.com.cn/docs/getting-started/ 安装gulp模块 准备工作：项目模块初始化 1$ npm init 建议全局安装一次 1$ npm install -g gulp 因为不同项目开发时依赖的gulp版本可能是不同的，避免构建工具的向下不兼容问题。建议具体项目依赖安装，加入依赖之后，模块的依赖以及对应版本会保存到package.json文件中。 1$ npm install -g gulp --save-dev 项目的根目录如果直接执行gulp命令，需要项目的根目录下新建gulpfile.js，必须是这个文件名，然后gulp构建的相关的js代码写到这个文件中。 gulp Api使用指南 作为常识要知道npm模块分两类：1 作为核心模块，可以直接用关键字加载请求下载使用 2 文件模块，按照文件的相对或者绝对地址，请求对应的文件模块（任何一个npm模块本质就是一个符合cmd or amd规范的js文件或者文件夹）。 通过require语法引入gulp模块 1var gulp =require(\"gulp\"); gulp.src(globs[, options]) 输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。（这里具体的匹配模式可以去github上去看详细的介绍，连接地址：https://github.com/isaacs/node-glob） 我们最常使用的是文件相对路径，这里只介绍几个常用的，*(a|b|c) 匹配零个或多个提供的模式；?(pattern|pattern|pattern) 匹配零个或所提供的模式之一；!(pattern|pattern|pattern) 匹配任何不匹配任何提供的模式;1234gulp.src('client/templates/*.jade') .pipe(jade()) .pipe(minify()) .pipe(gulp.dest('build/minified_templates')); gulp.dest(path[, options])能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。针对多个文件输出原位置时，只要指定父文件夹路径即可。 12gulp.src('./client/templates/*.jade') .pipe(gulp.dest('./build/minified_templates')); gulp.task(name[, deps], fn)使用场景：定义父任务与子任务，比如build任务包括html、css、js、img等多子任务。 1234gulp.task('task-name',[dep1,dep2],function()&#123; return gulp.src() .pipe()&#125;) gulp.watch(glob[, opts, cb])使用场景：监听文件，并且根据文件改变的不同做出不同响应的子任务或者简单记录文档变动日志 123456789#根据检测执行任务gulp.watch(([\"src/less/style.less\", \"src/less/**/*.less\"]), [\"less\"])；#根据检测查看更改类型，做日志信息gulp.watch('src/less/style.less',function(event)&#123; console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');&#125;)#根据检测,文件改变时执行任务gulp.watch(([\"src/less/style.less\", \"src/less/**/*.less\"]).on(\"change\",function()&#123;&#125;)； gulp的执行机制gulp默认是吧所有任务并发执行，并不会等待或者按顺序执行，在执行完成之后会进入 任务回调。如果需要制定执行顺序，给出一个提示，来告知 task 什么时候执行完毕，并且再给出一个提示，来告知一个 task 依赖另一个 task 的完成。 1234567891011var gulp = require('gulp');// 返回一个 callback，因此系统可以知道它什么时候完成gulp.task('one', function(cb) &#123; // 做一些事 -- 异步的或者其他的 cb(err); // 如果 err 不是 null 或 undefined，则会停止执行，且注意，这样代表执行失败了&#125;);// 定义一个所依赖的 task 必须在这个 task 执行之前完成gulp.task('two', ['one'], function() &#123; // 'one' 完成后&#125;);gulp.task('default', ['one', 'two']);","categories":[{"name":"npm","slug":"npm","permalink":"/localhost:4000/categories/npm/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"/localhost:4000/tags/gulp/"}]},{"title":"cnpm--企业npm仓库","slug":"cnpm","date":"2018-02-07T15:20:08.983Z","updated":"2018-02-07T15:20:08.984Z","comments":true,"path":"cnpm/","link":"","permalink":"/localhost:4000/cnpm/","excerpt":"我们常常会遇到npm请求慢，对模块介绍不清楚的情况；我们也会遇到自己想发布一个模块，但是只想自己或者部分内部人员使用；诸如此类，因此我们可能会需要一个企业仓库来实现以上的需求，它能够帮我们实现：1 将模块请求设置为内网响应，请求更快；2 在你需要的时候，将模块强制更新，也可以选择性的控制企业仓库只提供模块的对应版本；3 发布一些与业务或者公司内部的技术模块","text":"我们常常会遇到npm请求慢，对模块介绍不清楚的情况；我们也会遇到自己想发布一个模块，但是只想自己或者部分内部人员使用；诸如此类，因此我们可能会需要一个企业仓库来实现以上的需求，它能够帮我们实现：1 将模块请求设置为内网响应，请求更快；2 在你需要的时候，将模块强制更新，也可以选择性的控制企业仓库只提供模块的对应版本；3 发布一些与业务或者公司内部的技术模块 图解cnpm 快速入手全局安装cnpm1$ npm install -g cnpm --registry=http://192.168.0.234:7001 如果你已经安装了cnpm模块，那么重新设置请求地址即可，不需要覆盖安装1$ cnpm set registry http://192.168.0.234:7001 基本模块安装cnpm的使用与npm完全相同，只是把npm改为cnpm即可，没有使用难度。 安装机制：从 http://192.168.0.234:7001 安装所有模块. 当安装的时候发现安装的模块还没有同步过来, 企业NPM会自动在后台进行同步, 并且会让你从淘宝NPM：registry.npm.taobao.org 进行安装. 下次你再安装这个模块的时候, 就会直接从企业NPM安装了.1$ cnpm install [name] 手动同步模块1$ cnpm sync [name] 更新模块1$ cnpm update [name] 发布与删除模块备注：需要先用户登录,用户账号以及密码可以找运维部门索要配置。 用户登录 1$ cnpm login 模块初始化模块要想发布到npm仓库，必须有package.json的包说明文件，其他不做具体要求，可根据自己的需要灵活开发私属模块。建议通过cnpm init来实现模块包文件初始化。 12$ cd [name]$ cnpm init 发布模块 1$ cnpm publish [name] 删除模块 1$ cnpm unpublish [name] 其他 查看已知包名模块详情 1$ cnpm info [name] 也可以通过网址：http://192.168.0.234:7002 ，搜索响应的模块，查看web版本的介绍 更多详情参考: 公司内网cnpm仓库","categories":[{"name":"npm","slug":"npm","permalink":"/localhost:4000/categories/npm/"}],"tags":[{"name":"cnpm入门","slug":"cnpm入门","permalink":"/localhost:4000/tags/cnpm入门/"}]},{"title":"browserSync模块的使用（1）","slug":"browerSync模块的使用","date":"2018-02-07T15:20:08.983Z","updated":"2018-02-07T15:20:08.983Z","comments":true,"path":"browerSync模块的使用/","link":"","permalink":"/localhost:4000/browerSync模块的使用/","excerpt":"你经常会遇到项目代码修改调试然后重新刷新页面甚至清楚浏览器缓存的情况，下面提供一种方案为你提高下工作效率–browserSync. sd","text":"你经常会遇到项目代码修改调试然后重新刷新页面甚至清楚浏览器缓存的情况，下面提供一种方案为你提高下工作效率–browserSync. sd 前言它不但能够帮你实现同步代码到浏览器，而且可以实现多终端同时响应操作来进行你的开发工作，那么你在微信端调试你的页面遇到的问题或者代码的情况，谷歌浏览器也是可以看到，更多特性等待你去挖掘。 基本了解官方文档官网中文地址：http://www.browsersync.cn/官网中文说明： http://www.browsersync.cn/docs/github代码托管地址： https://github.com/BrowserSync/browser-sync 优点介绍 交互同步 文件同步 URL历史 同步定制 远程督察 URL通道 UI或命令行控制 浏览器支持 构建工具兼容 服务于任何本地站点 安装并运行在任何地方 空闲运行并再利用 安装与实现安装1234#全局安装$ npm install -g browser-sync#依赖安装$ npm install browser-sync --save-dev 实现原理Browsersync的工作原理是在标签之后插入初始请求的&lt;script async&gt;...&lt;/script&gt;) 异步脚本标记， 为了能够正常工作 &lt;body&gt;标签必须存在。另外，您可以为使用 snippetOptions代码段自定义规则 监听静态网站你可以对特定的文件进行监听，也可以对特定的文件进行监听，如果想监听整体的网站，那么设置–files “**”,文档模式为glob.补充说明默认所建服务器为本地3000端口并且在3001可以看到监测的同步情况。默认成功显示的是网站根目录index.html文件，如果没有提示can not get错误。如果有提示，conneted to browserSync. 1234# 启动服务器 监听所有的html文件$ browser-sync start --server --files \"*.html\"# 启动服务器 监听所有的文件$ browser-sync start --server --files \"**\" 基本命令行配置参数说明 下面只列出常用的参数，详细的请看官网说明参数| 说明—-|—-–help | 输出使用信息–files | 监听文件的匹配模式–version | 版本信息–browser | 选择哪个浏览器应该是自动打开–exclude |文件模式忽视–server| 运行本地服务器（使用您的CWD作为Web根）–index |指定哪些文件应该被用作索引页–proxy| 代理现有的服务器–host |指定主机名使用–port |指定要使用的端口 文件实例12345678910# 单个文件 $ browser-sync start --files \"css/core.css\"# 单模式$ browser-sync start --files \"css/*.css\"# 多个文件 $ browser-sync start --files \"css/core.css, css/ie.css\"# 多模式 $ browser-sync start --files \"css/*.css, *.html\"# 启动服务器 监听所有的文件$ browser-sync start --server --files \"**\" 服务器实例12345678# 使用当前目录为根＃静态服务器$ browser-sync start --server# 使用“应用程序”目录的根目录＃静态服务器$ browser-sync start --server app# 使用当前目录与目录列表根＃静态服务器 $ browser-sync start --server --directory 代理实例1234567891011# 使用local.dev虚拟主机$ browser-sync start --proxy# 使用local.dev虚拟主机与港口 $ browser-sync start --proxy local.dev:8001# 使用本地主机地址 $ browser-sync start --proxy localhost:8001# 使用本地主机地址 子地址$ browser-sync start --proxy localhost:8080/site1 重载选项可以选择重载 –files 重载，–port 端口重载 ，–url 提供完整的url重载12345# 重载http协议$ browser-sync reload# 重载带端口的HTTP协议$ browser-sync reload --port 4000 --files=\"*.css\" Browsersync APIBrowsersync API是难以置信的简单和强大。你可以用它来创建简单的开发任务或与其他工具配合使用完成复杂的任务。你要使用它， 只需要 require Browsersync 模块，就像您使用其他模块那样。以下是常用方法的详细说明： 创建方式 .create(name) ，Type: String,可稍后用于检索的标识符,在2.0.0+版本（推荐）这种方式创建服务 ,意味着你得到一个唯一的实例并允许您创建多个服务器或代理。1234567// 创建一个未命名的实例var bs = require(\"browser-sync\").create();// 创建一个命名实例var bs = require(\"browser-sync\").create('My server');// 创建多个var bs1 = require(\"browser-sync\").create('Server 1');var bs2 = require(\"browser-sync\").create('Server 2'); 获取实例 .get(name) ，可以通过名称获取实例。如果你有其他构建脚本在单独的文件，这很有用。12345678910// 在一个文件中创建一个命名实例... var bs = require(\"browser-sync\").create('My Server');// 初始化Browsersync服务器bs.init(&#123; server: true&#125;);// 现在，获取另一个实例。 var bs = require(\"browser-sync\").get('My server');// 并调用它的任何方法。 bs.watch('*.html').on('change', bs.reload); 初始化服务 .init( config, cb ) ，启动Browsersync服务。这将启动一个服务器，代理服务器或静态服务器，这取决于你实际需要。configType: Object [optional]这是你的Browsersync实例的主配置，并且可以包含任何可用的选项。如果你不使用已有的配置参数，Browsersync仍将运行; 但只能在 snippet 模式下cbType: Function [optional]如果你传递一个回调函数，它会在Browsersync已完成全部安装任务，并准备使用时被调用。或同步执行其他任务：当你需要等待信息（网址，端口等），这非常有用。1234567891011var bs = require(\"browser-sync\").create();// 开始一个Browsersync静态文件服务器bs.init(&#123; server: \"./app\"&#125;);// 开始一个Browsersync代理bs.init(&#123; proxy: \"http://www.bbc.co.uk\"&#125;); 重载.reload( arg ) ，该 reload 方法会通知所有的浏览器相关文件被改动，要么导致浏览器刷新，要么注入文件，实时更新改动。arg Type: String | Array | Object [optional]一个或多个文件被重新加载。12345678// 浏览器重载bs.reload();// 单个文件bs.reload(\"styles.css\");// 多个文件bs.reload([\"styles.css\", \"ie.css\"]);// 在2.6.0里 - 通配符来重新加载所有的CSS文件 bs.reload(\"*.css\"); 变化流.stream( opts ) 该 stream 方法返回一个变换流，并且可以充当一次或多个文件。opts Type: Object [optional]配置流的方法 （注: 至少需要2.6.0版本）1234567891011121314151617181920212223// 编译SASS且自动注入到浏览器gulp.task('sass', function () &#123; return gulp.src('scss/styles.scss') .pipe(sass(&#123;includePaths: ['scss']&#125;)) .pipe(gulp.dest('css')) .pipe(bs.stream());&#125;);// 提供 `once: true` 限制每个流重装一次gulp.task('templates', function () &#123; return gulp.src('*.jade') .pipe(jade()) .pipe(gulp.dest('app')) .pipe(bs.stream(&#123;once: true&#125;));&#125;);// 提供过滤器以被重新加载阻止不需要的文件gulp.task('less', function () &#123; return gulp.src('*.less') .pipe(less()) .pipe(gulp.dest('css')) .pipe(bs.stream(&#123;match: \"**/*.css\"&#125;));&#125;); 消息提醒.notify( msg, timeout ) 浏览器消息助手 msg Type: String | HTML 可以是一个简单的消息，如“连接”或HTMLtimeout Type: Number [optional]消息将保存在浏览器里时间设置。1.3.0版本12345678910var bs = require(\"browser-sync\").create();// 文本信息bs.notify(\"Compiling, please wait!\");// HTML信息bs.notify(\"HTML &lt;span color='green'&gt;is supported&lt;/span&gt; too!\");// 1.3.0版本，指定超时bs.notify(\"This message will only last a second\", 1000); 其他 更多方法参考官方文档：点击跳转","categories":[{"name":"npm","slug":"npm","permalink":"/localhost:4000/categories/npm/"}],"tags":[]},{"title":"前端工程化的探索（一）","slug":"前端工程化的探索","date":"2018-02-07T15:20:00.000Z","updated":"2018-02-08T01:19:23.814Z","comments":true,"path":"前端工程化的探索/","link":"","permalink":"/localhost:4000/前端工程化的探索/","excerpt":"在大前端的趋势下，原来的切图仔或者说前端工程师已经不能承载实际需要，在开发以及调试中，我们需要一系列的方案来让我们的项目变得优化，规范，可配置等。本文就这方面做简单分析，并列出了一系列的解决方案，","text":"在大前端的趋势下，原来的切图仔或者说前端工程师已经不能承载实际需要，在开发以及调试中，我们需要一系列的方案来让我们的项目变得优化，规范，可配置等。本文就这方面做简单分析，并列出了一系列的解决方案， 了解我们所处的阶段前端从无到有，从简单到复杂，从手动到配置，从融合到后端到主导用户应用，不断的对前端的工程化提出了新的概念和挑战，而在这一系列的工具或者方法中，简单分出以下几个阶段。 stage1：库、框架的选型前端工程建设的第一项任务就是根据项目特征进行技术选型。基本上现在没有人完全从0开始做网站，最少都会选下jquery，而React/Angularjs等框架横空出世，也让前端对页面交互、路由控制等有了更多的话语权。 stage2：简单构建完成项目之后，一般我们都需要对项目中引用的文件进行简单的优化，包括校验、压缩、合并等，而目前市场上提供的构建工具有grunt,gulp,fis以及webpack等。而市场上目前能做到这个阶段在业界来说已然超出平均水平，属于“具备较高工程化程度”的团队了，查看中国中小企业的网页源代码，能做到最基本的JS/CSS压缩的Web应用都已跨入标准互联网公司行列，不难理解为什么很多前端团队对于前端工程构建的认知还仅停留在“压缩、校验、合并”这种程度。但是我们必须将自己的前端工作做到行业的前列，所以当下我们在仅仅停留在第一阶段的时候，需要快速进入第二阶段，迈向第三阶段。 stage3:JS/CSS模块化开发分而治之是软件工程中的重要思想，是复杂系统开发和维护的基石，这点放在前端开发中同样适用。在解决了基本开发效率运行效率问题之后，前端团队开始思考维护效率，模块化是目前前端最流行的分治手段。很多人觉得模块化开发的工程意义是复用，我不太认可这种看法，在我看来，模块化开发的最大价值应该是分治，只有根据自己的业务需要不断的整合并且开出新的分之，并且分别维护才可以让业务或者技术更加纯熟。而简单的模块复用是不足以应对复杂，多变的需求的。分治的本质就是针对一对代码，一个文件，我们都应该将其定义为模块。JS模块化方案很多，AMD/CommonJS/UMD/ES6 Module等，对应的框架和工具也有很多；CSS模块化开发基本都是在less、sass、stylus等预处理器的import/mixin特性支持下实现的（本博客系统就是基于stylus实现）。 stage4：工程化问题的爆发首先要认识到，前端是一种技术问题较少、工程问题较多的软件开发领域。很多人觉得前端门槛低，但是真到这个行业发现有若干的坑需要踩，没有写几行代码那样简单。那可能遇到什么问题呢？ 大体量：多功能、多页面、多状态、多系统； 大规模：多人甚至多团队合作开发； 高性能：CDN部署、缓存控制、文件指纹、缓存复用、请求合并、按需加载、同步/异步加载、移动端首屏CSS内嵌、HTTP 2.0服务端资源推送。 解决方案如果要解决上面的问题，我觉得应该从以下几个方面入手，以后也将重点就以下几个方面以及项目中的具体问题做拓展。 整体规范 设计规范设计规范是一个前端工程界面部分规范不可或缺的部分，如果设计以及产品不能按照一定的规范执行，那么最终的产品体验以及工程化产物也是复用度很低，不适用于大多数项目的。所以要求公司对所有的公司产品从原型设计到设计稿设计，有整套的设计规范，去除不必要的自由发挥。 前端代码规范从源头开始制定代码规范，所有的代码符合这一规范，目前制定了包括html\\css\\js\\less在内的代码规范。针对前端项目中遇到的问题，也将统一制定解决方案。比如web视频解决方案，时间控件解决方案，二维码解决方案等。 构建规范从构建工具开始，每一个细节告诉开发成员应该如何操作，怎样才是规范的，提供完整详细的教程文档以及辅导体制。减少使用不必要的，不规范的代码压缩、验证操作以及不规范的文档结构。 组件化开发前端作为一种GUI软件，光有JS/CSS的模块化还不够，对于UI组件的分治也有着同样迫切的需求。为了更好的实现代码复用，提高工作效率，我强烈建议在项目团队中应该有一定比例的人负责ui组件的开发。而另一部分人是负责使用以及维护，并不断提出优化建议。组件化开发的图示应该是下图所示：提到组件开发，不仅仅是前端项目可以用，在很多以后台为主导的项目，组件的思路也可以得到灵活的应用。由此可见，以后我们应该更灵活的开发样式，脚本等。在提供一个大而全的框架的同时，也提供让用户可以根据自己的一个小需求，仅仅引入一个小的组件。如果有以上的工程概念，那么为了实现优化，我们需要针对不同的组件指定开发者，并在一个开源项目上让大家的组件都是可见的。并且可以无缝的融合到一起，如果要做到这一点，就必须共同遵循同一套规则。其中版本管理的建议用git，而公司内部的gitlab已经为我们提供了便利条件。不同人员分工的图示如下： 不同维度就项目而言，一个组件是远远不够的，在实际的开发当中，我们的使用是分很多种情况的。有的时候需要根据自己的业务，有的时候需要根据自己的组件，而有时候又是仅仅需要某些页面。所以针对不同的情况，我们可以参考以下的图示，同时需要了解到这种情况是允许存在的。如果放到一个项目中，可能就是下图所示的结构。针对中小型项目，建议的文档结构，也是我们目前正在逐步普及的目录结构。最常见的页面+less组件维度。 静态资源管理如果说前端对客户端的优点，目前的界面以及交互式肯定比不上的，但是前端的gui界面没有安装的概念，而安装的概念就是把客户端里需要的ui全部本地存储一份。那如果前端在第一次需要的时候就加载全部文件，显然也是不合理的，所以规范的web应用也不会这么做。一般的做法是针对需求做增量更新，最常见的例子就是12306每次的web升级包，虽然它交互并不好。由“增量”原则引申出的前端优化技巧几乎成为了性能优化的核心，有加载相关的按需加载、延迟加载、预加载、请求合并等策略；有缓存相关的浏览器缓存利用，缓存更新、缓存共享、非覆盖式发布等方案；还有复杂的BigRender、BigPipe、Quickling、PageCache等技术。这些优化方案无不围绕着如何将增量原则做到极致而展开。资源管理的蓝图如下：其中构建工具的部分是通用的，具体选用的时候是针对性的。 工程化实践技术选型规范：已制定的相关文档版本管理： git，严格按照版本管理+分之管理进行（支持多分之，bug分之，功能分之等）开源项目仓库：github,gitlab开发目录： src+dist+lib+test(测试)+ node_modules +bower_components前端构建工具： gulp +gulp基本插件（gulp-less等）组件开发工具：less前端页面模板引擎：tmod，artTemplate前端框架选型：jq+boot+jq插件前端ide ：hbuilder+emmet开发环境：chrome+devTool +模拟器包管理器：npm -package.json（npm init ,npm (un)publish,npm install）依赖资源加载：bower同步调试：browserSync 多终端同步调试工具前端依赖模块（浏览器环境）：requirejs (seajs)js模块化： cmd,amd模块规范前端服务器：nodejs 技术创新部分 cnpm企业仓库支持内网npm仓库，比npm请求更快。支持企业内部的npm模块发布与使用。 gulp项目构建支持常见的插件使用，支持gulp的构建实践，实现了开发与生产目录的分离，切实的优化了web项目。 less组件命名规范化基于模块化之后的深度理解，着重使用less的相关规则，将样式拆分为不同分类，还有不同组件，将css的技术解决方案、兼容方案融合到组件当中。 npm模块的定义与发布研究了npm js模块的发布机制，可以自行发布模块，供内部员工使用。 bower静态资源加载机制对项目中需要用到的资源，统一用bower依赖加载，不再用复制粘贴的方式。 调试开发（browserSync）摒弃手动多端测试，实现多终端自动测试，开发同步修改。 代码规范针对公司全体前端制定代码规范，提供前端页面初始化模板。 多环境集成git包括git bash,toriseGit,hb,ws,eclipse多软件集成，让git版本管理使用便携。同时深度调研git版本管理命令行，提供git版本管理入门123系列教程，为公司提供技术支持。 nrm无痛切换多源可以让你在内网，外网多环境下使用npm命令行 npm加载请求机制可以根据自己的需求，灵活选择缓存安装还是本地代理安装还是企业内网安装 静态资源的优化探索（待补充） 其他本文部分内容参考以下文档，表示真心的感谢！ fouber：[前端工程化基础篇]","categories":[{"name":"web","slug":"web","permalink":"/localhost:4000/categories/web/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"/localhost:4000/tags/前端工程化/"}]},{"title":"markdown教程（2）","slug":"markdown教程（2）","date":"2016-12-21T11:40:03.000Z","updated":"2018-02-07T15:20:08.988Z","comments":true,"path":"markdown教程（2）/","link":"","permalink":"/localhost:4000/markdown教程（2）/","excerpt":"本教程基于基本教程1，拓展了一些你其他可能需要的便捷语法.","text":"本教程基于基本教程1，拓展了一些你其他可能需要的便捷语法. 表格表格头与表格用—|— 隔开 ，每列用|隔开即可。需要注意的是表格需要空一行开始。 项目 描述 产品 自行车 流程图github参考地址定义元素阶段的语法是 :tag=&gt;type: content:&gt;url 时序图时序图主要有一下几个元素：角色，对象，生命线，激活器和消息. 其他待补充中…","categories":[{"name":"web","slug":"web","permalink":"/localhost:4000/categories/web/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"/localhost:4000/tags/markdown/"}]},{"title":"markdown教程（1）","slug":"markdown教程（1）","date":"2016-12-21T11:39:51.000Z","updated":"2018-02-07T15:20:08.987Z","comments":true,"path":"markdown教程（1）/","link":"","permalink":"/localhost:4000/markdown教程（1）/","excerpt":"Markdown 语法的目标是：成为一种适用于网络的书写语言,那么作为爱写文章的你应该掌握下它的基本语法。","text":"Markdown 语法的目标是：成为一种适用于网络的书写语言,那么作为爱写文章的你应该掌握下它的基本语法。 概述官方中文地址mdeditor在线教程 兼容 HTML 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的&lt;p&gt; 标签。 比如下面的表格就是用html代码完成的，并不冲突。在hexo驱动中，可能需要去空行压缩处理才能去掉多余的换行。 &lt;table&gt; &lt;tr&gt; &lt;td&gt;自定义名称&lt;/td&gt; &lt;td&gt;自定义描述&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;xx&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 自定义名称自定义描述姓名xx 特殊字符自动转换类似html文件中： &lt; 和 &amp; ，markdown会自动转化，不需要手动处理。 区块元素段落和换行连续的文本都会识别为一个段落， 中间有换行识别为换行，如果想另起一个段落需要中间加空白行。 标题 Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：任何数量的 = 和 - 都可以有效果。 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：末尾的闭合可以不用加. 区块引用Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。内部可以在写引入或者列表，你可以在一个引入内只写一个，避免重复。 列表的使用无序列表可以用*、-、+等，熟练使用一种即可；有序列表用数字加英”.” ,数字不会影响有序列表的显示。需要注意的是无序和有序列表内容开始之前都要加空格，另外一个项目之内有空白行的会把之前的内容用p标签包裹。 代码区块代码区块可以用一个tab或者四个空格。 分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线。 区段元素链接用中括号写连接文字，小括号写连接地址，或者冒号加连接地址(地址可以为相对地址)。 强调Markdown 使用星号（）和底线（_）作为标记强调字词的符号，被 或 包围的字词会被转成用 标签包围，用两个 * 或 包起来的话，则会被转成 代码反引号可以用来引入代码，引入代码段用3个“`“+ codetype 开始，以 3个“`“结束即可。 图片叹号+中括号+图片路径，目前没办法指定图片大小，可以使用普通的img标签来定义图片。 其他反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 标签），你可以在星号的前面加上反斜杠 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。https://csnikey.github.io/blog","categories":[{"name":"web","slug":"web","permalink":"/localhost:4000/categories/web/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"/localhost:4000/tags/markdown/"}]},{"title":"http请求优化（一）","slug":"http请求优化（一）","date":"2016-12-20T01:15:20.000Z","updated":"2018-02-07T15:20:08.986Z","comments":true,"path":"http请求优化（一）/","link":"","permalink":"/localhost:4000/http请求优化（一）/","excerpt":"相信有不止一个人给你推荐过web优化中药减少并简化请求，比如使用图片精灵，合并压缩文件，脚本文件写在dom末尾，那么今天我们从http这个角度去分析，去做一些有意义的探索。","text":"相信有不止一个人给你推荐过web优化中药减少并简化请求，比如使用图片精灵，合并压缩文件，脚本文件写在dom末尾，那么今天我们从http这个角度去分析，去做一些有意义的探索。 http瀑布图入门如果说你想了解下http的请求情况或者想优化页面初始化的效率，那么http瀑布图是你不可缺少的一个分析工具。如下图所示：下面分别展示了一个页面打开的所有请求以及一个资源请求的详细情况。从下面的图中你既能看到不同请求的请求顺序，请求时间，也能看到资源是同步加载的，脚本会阻塞加载，另外渲染和js执行属于不同的引擎负责，等等。在后面的文章中，我会分别介绍如何去分析这些图，并根据这些图去优化对应的部分。 http协议的类型科普内容： 物理层：以太网 · 调制解调器 · 电力线通信(PLC) · SONET/SDH · G.709 · 光导纤维 · 同轴电缆 · 双绞线等数据链路层：Wi-Fi(IEEE 802.11) · WiMAX(IEEE 802.16) ·ATM · DTM · 令牌环 · 以太网 ·FDDI · 帧中继 · GPRS · EVDO ·HSPA · HDLC · PPP · L2TP ·PPTP · ISDN·STP 等网络层协议：IP (IPv4 · IPv6) · ICMP· ICMPv6·IGMP ·IS-IS · IPsec · ARP · RARP等传输层协议：TCP · UDP · TLS · DCCP · SCTP · RSVP · OSPF 等应用层协议：DHCP ·DNS · FTP · Gopher · HTTP· IMAP4 · IRC · NNTP · XMPP ·POP3 · SIP · SMTP ·SNMP · SSH ·TELNET · RPC · RTCP · RTP ·RTSP· SDP · SOAP · GTP · STUN · NTP· SSDP · BGP · RIP 等 http的通信流程： http的消息结构： http连接注意事项HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 http版本0.9 只接受get，过时；1.0 大多数网站使用；1.1 当前版本。持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。2.0 符合spdy协议，二进制格式在协议的解析和优化扩展上带来了跟多的优势，对消息头采用Hpack进行压缩传输，能够节省消息头占用的网络流量，异步连接多路复用，Server Push，服务器端能够更快的把资源推送到客户端，保持了与HTTP 1.1语义的向后兼容性 http种类：HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL(ssl用户安全认证)。cdn请求:为什么有的文件用cdn加速之后就没有写协议类型，因为当前协议类型有可能是http or https不确定的，写//会自动识别当前的页面请求类型。data:image/png;base64：为什么没有协议类型，本身属于符合RFC2397的Data URI scheme，不需要加载文件，知识一部分内容直接用于输出，图片是2进制的，所以一般需要转换为64进制。除了这个之外，还有其他类型：比如：data:text/plain,&lt;文本数据&gt; ，data:text/css, ,data:image/x-icon;base64,base64编码的icon图片数据等，详细文档请站内搜索“Data URI scheme”。 http请求状态码 HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。http常见的状态码以及代表含义作为前端要清楚，并且正确的运用。以下只提供了部分常见的，如果大家想了解更多可以参考以下在线文档:百度百科 / 菜鸟教程1 1xx 信息正在处理 2 2xx 请求成功 状态码 描述 200 ok 请求被成功处理 201 请求成功，并且服务器创建了新的资源 202 服务器已经接受请求，但还没有处理 203 服务器已经处理了请求，但是信息来自于另一个来源 204 请求成功，但是服务器没有响应体 205 处理了请求，但没有返回内容，要求请求者重置内容再次请求 206 部分内容，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求 3 3xx 重定向状态码 状态码 描述 301 永久性重定向 302 临时性重定向 304 未被修改，不会返回新内容 4 4xx 代表请求错误 状态码 描述 401 未被授权 403 服务器拒绝请求 404 页面或者文件找不到 405 禁用请求中的指定方法 408 请求超时 414 请求uri过长 417 请求参数不符合标准 5 5xx 服务器错误 状态码 描述 500 服务器内部错误 501 服务器不具备响应此需要的功能 502 错误网关 503 服务不可用，比如系统维护或者升级等 504 网关超时 505 http协议版本不支持 http请求类型共8种请求类型，常见的是get和post请求，所有的这些类型都参与js-restful的设计。根据HTTP标准，HTTP请求可以使用多种请求方法。HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 状态码 描述 GET 请求指定的页面信息，并返回实体主体 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改 DELETE 请求服务器删除指定的页面 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器 OPTIONS 允许客户端查看服务器的性能 TRACE 回显服务器收到的请求，主要用于测试或诊断 get与post方式区别首先要了解清楚的一点是：我们大多数的请求是get方式的，少数表单或者数据操作是post的，ajax异步多是post.选择上：如果你希望url可见，可被分享抓取，可手动修改参数访问，希望被缓存，参数较短，主要是受限于url长度，那么考虑用get。需要注意的一点是：需要上传文件的要用post. 1.GET被浏览器强制支持（POST是可选的，不过一般都支持）2.GET是幂等的，POST非幂等(幂等每次请求不会对系统造成影响，而post有可能会更新数据)3.GET可以被浏览器缓存，POST不可以（比如访问的历史记录，请求的历史文件，比如样式文件等）4.GET请求是『安全』的，POST不安全(这里的安全还是指的不会更新数据)5.POST相对来说比GET要『安全』一些(操作安全，参数等不可见)6.参数大小（理想和现实）","categories":[{"name":"web","slug":"web","permalink":"/localhost:4000/categories/web/"}],"tags":[]},{"title":"nodejs入门","slug":"nodejs入门","date":"2016-12-13T07:34:46.000Z","updated":"2018-02-07T15:20:08.988Z","comments":true,"path":"nodejs入门/","link":"","permalink":"/localhost:4000/nodejs入门/","excerpt":"作为前后端分离趋势的技术支持，nodejs一直扮演着重要的角色，那么在实际的项目中，nodejs究竟可以做哪些，又有什么便利之处呢？","text":"作为前后端分离趋势的技术支持，nodejs一直扮演着重要的角色，那么在实际的项目中，nodejs究竟可以做哪些，又有什么便利之处呢？ 基础什么是nodejsjs语言的运行环境，提供了一系列的内置对象。 用途1 web服务器2 调试js片段3 编写前端工具4 etc… 安装NodeJS 提供了一些安装程序，都可以在 nodejs.org 这里下载并安装。Windows 系统下，选择和系统版本匹配的 .msi 后缀的安装文件。Mac OS X 系统下，选择 .pkg 后缀的安装文件。编译安装（linux系统下，win系统可以忽略）Linux 系统下没有现成的安装程序可用，虽然一些发行版可以使用 apt-get 之类的方式安装，但不一定能安装到最新版。因此 Linux 系统下一般使用以下方式编译方式安装 NodeJS。1.确保系统下 g++ 版本在 4.6 以上，python 版本在 2.6 以上。2.从 nodejs.org 下载 tar.gz 后缀的 NodeJS 最新版源代码包并解压到某个位置。3.进入解压到的目录，使用以下命令编译和安装。1234567891011$ ./configure$ make$ sudo make install``` ### 运行* win运行打开终端，键入 node 进入命令交互模式，可以输入一条代码语句后立即执行并显示结果，例如：``` bash$ node&gt; console.log('Hello World!');Hello World! 如果要运行一大段代码的话，可以先写一个JS文件再运行。例如有以下 hello.js。1234function hello()&#123; console.log(\"hello world\");&#125;hello(); 写好后在终端下键入 node hello.js 运行，结果如下：1$ node helloworld.js 模块编写稍大一点的程序时一般都会将代码模块化。在 NodeJS 中，一般将代码合理拆分到不同的 JS 文件中，每一个文件就是一个模块，而文件路径就是模块名。 在编写每个模块时，都有 require、exports、module 三个预先定义好的变量可供使用。 require 定义需要依赖的模块require 函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。以下是一个例子。 1234var foo1 = require('./foo');var foo2 = require('./foo.js');var foo3 = require('/home/user/foo');var foo4 = require('/home/user/foo.js'); exportsexports 对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过 require 函数使用当前模块时得到的就是当前模块的 exports 对象。以下例子中导出了一个公有方法。 123exports.hello = function () &#123; console.log('Hello World!');&#125;; module通过 module 对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。 123module.exports = function () &#123; console.log('Hello World!');&#125;; 模块初始化一个模块中的 JS 代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。主模块通过命令行参数传递给 NodeJS 以启动程序的模块被称为主模块。主模块负责调度组成整个程序的其它模块完成工作。例如通过以下命令启动程序时，main.js 就是主模块。完整示例 例如有以下目录。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/localhost:4000/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"/localhost:4000/tags/nodejs/"},{"name":"nodejs入门","slug":"nodejs入门","permalink":"/localhost:4000/tags/nodejs入门/"}]},{"title":"js-Date日期格式的转换","slug":"js-Date日期格式的转换","date":"2016-12-12T15:29:07.000Z","updated":"2018-02-07T15:20:08.987Z","comments":true,"path":"js-Date日期格式的转换/","link":"","permalink":"/localhost:4000/js-Date日期格式的转换/","excerpt":"js之Date类型的对象支持一些日期格式的转换，下面为你介绍你可能用到的一些日期转换方法","text":"js之Date类型的对象支持一些日期格式的转换，下面为你介绍你可能用到的一些日期转换方法 * js日期格式转换 字符串变时间var date=new date('yyyy-mm-dd') 可以直接从字符串转变为时间对象的格式有标准格式的字符串的格式可以直接创建时间对象,格式通过正则验证，date对象可以直接通过大小比较早晚var date=new Date('2012-12-12'); var date=new Date('2012,12,12'); var date=new Date('2012,12,12,12:12'); var date=new Date('2012,12,12,12:12:34'); 对象变字符串var date1=new Date(); var year=date1.getFullYear(); var mon=date1.getMonth()+1; var day=date1.getDate(); var str2=year+\",\"+mon+\",\"+day+\",\"+\"18:05\"; //截至时间的半小时以前 获取半小时之前的时间 var date2=new Date(str2).getTime()-1000*60*30; var date11=date1.getTime(); console.log(date11&lt;=date2); 参考文档：w3c日期对象 js日期转换方法 自定义的工具方法，支持转换日期对象为日期以及日期时间function todatestr( datat) { var year = datat.getFullYear(); var m = datat.getMonth() + 1 ; var da = datat.getDate(); var str = year + \"-\" + m + \"-\" + da; return str; } function totimestr( datat) { var hours = datat.getHours(); var min = datat.getMinutes(); if (min &lt; 10) { min = \"0\" + min; } var str = hours + \":\" + min; return str; } java日期格式转换 java自带封装好的转换工具String createTime='2014-12-24'; DateFormat dd=new SimpleDateFormat(\"yyyy-MM-dd\"); Date creatTime = dd.parse(createTime); //时间转变为字符串： Date date=new Date(); var df = new SimpleDateFormat(\"yyyy-MM-dd\" ); String formatDate = df.format(date);","categories":[{"name":"js","slug":"js","permalink":"/localhost:4000/categories/js/"}],"tags":[]},{"title":"css中超出为省略号的实现","slug":"css中超出为省略号的实现","date":"2016-12-12T07:34:46.000Z","updated":"2018-02-07T15:20:08.984Z","comments":true,"path":"css中超出为省略号的实现/","link":"","permalink":"/localhost:4000/css中超出为省略号的实现/","excerpt":"文本超出为省略号在很多位置都会用到，作为一个基本样式或者说原子类样式，我们需要知道其实现原理为什么。","text":"文本超出为省略号在很多位置都会用到，作为一个基本样式或者说原子类样式，我们需要知道其实现原理为什么。 使用场景文字内容过多，超出盒子模型的内容显示为省略号。提示：无论是单行还是多行文本，都需要设置高度，行高，超出不可见。（仅供参考） 文本单行省略.demo{ white-space:nowrap;（超出不换行，默认为换行的） text-overflow:ellipsis;（省略号样式） //代码部分 完整部分 overflow: hidden; white-space:nowrap; text-overflow:ellipsis; } 文本多行省略 (webkit)white-space:normal;（超出宽度换行） text-overflow: ellipsis; （省略号样式） -webkit-box-orient: vertical; -webkit-line-clamp: 3;（行数） display: -webkit-box;（展示盒子模型类型） //代码部分(供拷贝) overflow:hidden; white-space:normal; text-overflow: ellipsis; -webkit-box-orient: vertical; -webkit-line-clamp: 3; display: -webkit-box; 其他方案 引入jq插件，待补充","categories":[{"name":"css","slug":"css","permalink":"/localhost:4000/categories/css/"}],"tags":[{"name":"text-overflow","slug":"text-overflow","permalink":"/localhost:4000/tags/text-overflow/"}]},{"title":"html之table标签的基本使用","slug":"html之table基本使用","date":"2016-12-12T01:28:01.000Z","updated":"2018-02-07T15:20:08.986Z","comments":true,"path":"html之table基本使用/","link":"","permalink":"/localhost:4000/html之table基本使用/","excerpt":"表格作为页面展现中一部分不可获取，尤其在后台管理界面中，我们对之既爱又恨。那么它有哪些样式需要控制呢,又有哪些你所不知道的。本文通过一个简单的table实例来帮你解析实现一个table表格实例所需要的基础知识。","text":"表格作为页面展现中一部分不可获取，尤其在后台管理界面中，我们对之既爱又恨。那么它有哪些样式需要控制呢,又有哪些你所不知道的。本文通过一个简单的table实例来帮你解析实现一个table表格实例所需要的基础知识。 基本了解 表格标题用caption标签，标头的用thead， 表格内容用tbody ，一个表格默认只有一个标题一个表格头 一个表格内容，标题标签的高度不算入table 的高度 ，表格的默认样式需要修正初始化 一般情况下针对数据表格建议使用table标签，做好每个表格所需要的枚举数据项总数（如每页10条），做好分页以及意外数据处理，当然也可以用div模拟表格布局。 td默认会根据内容扩充的，而且布局不是固定布局，为了统一美化处理，需要对每一个单元格做限制单行高宽，如果必须为多行文本且限制高度，内部再加div高度，td本身写高度以及行高是无法限制的，如果不需要处理的采用自动拓展高度即可 针对数据项的宽度可以采用百分比或者固定数值布局，需要根据不同数据项的需求采用合适的宽高以及样式，例如身份证号、日期等要给合适的宽度，而标题长字段的要给较大的宽度值等 设置宽度只需要在数据项的名称设置一次即可，后面的表格内容布局会自动参考上面的比例 colspan为合并列，rowspan为合并行，在布局明显为表格而且有合并单元格时，建议用table实现，简约大方 代码实践 html代码部分&lt;table class=\"tableDemo\" &gt; &lt;caption &gt;我是表格的标题&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt;&lt;th class=\"no\"&gt;编号&lt;/th&gt; &lt;th class=\"name\"&gt;姓名&lt;/th&gt; &lt;th class=\"idno\"&gt;身份证号&lt;/th&gt; &lt;th class=\"desc\"&gt;描述&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;001&lt;/td&gt;&lt;td&gt;李四赵武&lt;/td&gt;&lt;td&gt;131102199010242011&lt;/td&gt;&lt;td&gt;13110219901024201的v的的v的的v的的v的1&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;002&lt;/td&gt;&lt;td&gt;张三&lt;/td&gt;&lt;td&gt;131102199010242011&lt;/td&gt;&lt;td&gt;13的1&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;002&lt;/td&gt;&lt;td&gt;张三&lt;/td&gt;&lt;td&gt;131102199010242011&lt;/td&gt;&lt;td&gt;13的1&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;002&lt;/td&gt;&lt;td&gt;张三&lt;/td&gt;&lt;td&gt;131102199010242011&lt;/td&gt;&lt;td&gt;13的1&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;002&lt;/td&gt;&lt;td&gt;张三&lt;/td&gt;&lt;td&gt;131102199010242011&lt;/td&gt;&lt;td&gt;13的1&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; css代码部分 *{ margin: 0; padding: 0; } .tableDemo { width: 800px; /*实际高度286px，如果不清楚实际高度可以不写*/ /*height:251px;*/ border: 1px solid grey; /*采用固定数据项的宽度决定布局*/ table-layout: fixed; /*控制表格外间距*/ border-spacing: 0; /* 设置合并边框*/ border-collapse: collapse; } /*表格标题栏的样式*/ .tableDemo caption { height: 40px; line-height: 40px; font-size: 30px; } /*每一行的数据项*/ .tableDemo tr { height: 40px; line-height: 40px; } .tableDemo tr th, .tableDemo tr td { border: 1px solid grey; } /*table中的表格不能做多行超出隐藏 只能通过内部div的设置超出隐藏，这里直接设置内容为单行超出隐藏*/ .tableDemo tr td { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } .tableDemo th { line-height: 40px; height: 40px; } /*针对各个数据项给不同的宽度*/ .tableDemo .no { width: 100px; } .tableDemo .name { width: 150px; } .tableDemo .idno { width: 250px; } 效果图如下","categories":[{"name":"html","slug":"html","permalink":"/localhost:4000/categories/html/"}],"tags":[{"name":"table","slug":"table","permalink":"/localhost:4000/tags/table/"}]},{"title":"js编码规范","slug":"js编码规范","date":"2016-12-12T01:27:31.000Z","updated":"2018-02-07T15:20:08.987Z","comments":true,"path":"js编码规范/","link":"","permalink":"/localhost:4000/js编码规范/","excerpt":"在js的代码开发中，我简单的总结出了以下规则，后面会陆续补充并且对规范进行分类。","text":"在js的代码开发中，我简单的总结出了以下规则，后面会陆续补充并且对规范进行分类。 js代码建议保存到后缀名.js的文件中 js代码不建议放在html中，原因有：不能被缓存，会增大网页文件的大小，会影响页面的加载。另外脚本的lang以及type属性都可以省略。 缩进，建议使用空格，因为各个环境对tab的解释不通，而空格可以在压缩文件中统一被压缩掉。 每行控制在80个字符以内，如果超过请折行。 注释 ：注释可以增加代码的可维护性，尤其在项目交接的时候。写好注释有利于团队的集成开发。在更新功能以及模块时通过注释进行补充说明。写有意义的注释，关键位置的说明。 变量声明：在所有的变量使用前进行声明；变量没有块的概念；注意全局变量与布局变量，避免使用全局变量，同时避免局部变量覆盖全局变量。在函数体内，注意函数变量的说明，尤其很多入参或者出参的时候。 函数声明：所有的函数应该在使用前被声明；函数声明格式，函数名与左括号无间隔，右括号与方法体大括号有空格，大括号结束符与方法声明行头部对齐。（快捷键crtl+shift+f）特别的，如果是匿名函数，应该在方法类型与小括号之间加空格。 命名 ：变量名由26个大小写引文字母以及下划线组成，避免使用中文，不要再变量名中使用斜杠或者美元符号，不要把下划线用作变量的第一个字符，它有时会用作对象的私有变量，大多数的变量或者方法名应该以小写字母开头。全局变量应该全部大写字母。 语句 ：9.1 简单语句每一行语句最多只包含一条语句，吧分号放在每个简单语句的结尾。注意每个变量或者对象的赋值语句也是简单语句，应该以分号结尾。js吧任何表达式都当一条简单语句，会导致一些隐性的错误。如果自己没加分号，那么js解释器会自动添加分号，按照自己能读懂的断句。9.2 复合语句也称为语句块，被包在大括号内部。内部的语句块需要缩进四个空格，左大括号在起始行的结尾处，右大括号与左大括号所在行的开头对齐。大括号要在使用语句块的时候使用，哪怕只有一句，这样可以避免以后再添加语句的时候造成逻辑错误，比如if else 这样的语句中，默认只对单行代码有效 。 标识 ：标识是可选的，只有在do,while,for,switch中使用。 return 语句当返回语句只有一条返回值的时候，不用加小括号；当返回语句多个值的时候，小括号。当返回表达式的时候，应该控制在同一行，分号结尾。 基本语句的格式，按照正确的句法，比如if,else,for,switch 等 空白 ：相关程序之间添加空白行增强程序的可读性。每个控制结构，比如for循环的三个分支之间。变量声明时每个逗号之间。 变量作用域js没有有块级作用域，只有函数作用域。 [] {} 的用法使用直接量发来声明对象和数组。比如对象 var obj={} ;var arr=[] evaleval是最容易混乱使用的js函数，他可以执行内部入参的js函数或者表达式，可以直接解析变量。不建议使用 。 不建议修改内建对象的原型链内建对象的原型链 是比较好的标准 自己不要修改内建对象的相关方法 在内建对象的es5 es6 语法中有哪些 this关键字的使用场景 ：全局变量 ，触发元素，构造器本身，定义域 明确真值表明智的使用真假判断 (a==true)(a) 1234567891011- logTruthyFalsy(true); // truthy- logTruthyFalsy(1); // truthy- logTruthyFalsy(&#123;&#125;); // truthy- logTruthyFalsy([]); // truthy- logTruthyFalsy('0'); // truthy- logTruthyFalsy(false); // falsy- logTruthyFalsy(0); // falsy- logTruthyFalsy(undefined); // falsy- logTruthyFalsy(null); // falsy- logTruthyFalsy(NaN); // falsy- logTruthyFalsy(''); // falsy 判断是否相等时候 采用=== 判断包括类型的相等 尽量使用语法严格模式消除代码之中的不友好；代码运行更快 ；保证运行的安全 ；为新版本的js做好铺垫。 匿名函数的调用写在匿名函数的内部（function(argus){ }(argus))","categories":[{"name":"js","slug":"js","permalink":"/localhost:4000/categories/js/"}],"tags":[]},{"title":"css之两端对齐","slug":"css之两端对齐","date":"2016-12-12T01:26:02.000Z","updated":"2018-02-07T15:20:08.984Z","comments":true,"path":"css之两端对齐/","link":"","permalink":"/localhost:4000/css之两端对齐/","excerpt":"引言 ：文本内容总是左对齐，显得呆板，试试样式的两端对齐吧。","text":"引言 ：文本内容总是左对齐，显得呆板，试试样式的两端对齐吧。 探索过程浏览器参照基准：Firefox4 and Later, Chrome5 and Later, Safari5 and Later, Opera10.53 and Later, IE5.5 and Later.两端对齐方案基于 text-align:justify 及 text-align-last:justify 实现. IE实现 :justify最先是作为IE私有属性实现 div{text-align:justify;text-align-last:justify;} Firefox实现: text-align-last 在Firefox12-17下仍处理实验支持阶段，需加前缀 -moz- div{text-align:justify;-moz-text-align-last:justify;} Chrome, Safari, Opera实现 div{overflow:hidden;height:19px;text-align:justify;}div:after{display:inline-block;content:’’;overflow:hidden;width:100%;height:0;} 总结Chrome23, Safari5.1.7, Opera12.11 不支持 text-align-last, 但支持 text-align 的 jsutify, 所以这里可以变通实现单行文本两端对齐对齐，我们知道text-align:justify 不处理块内的最后一行文本（包括块内仅有一行文本的情况，这时既是第一行也是最后一行）及被强制打断的行的两端对齐，但会处理除此之外的其它行，所以只需要将这里的单行变成多行即可，那么我们可以使用伪对象的方式派生出新行，这样不需要额外处理html代码，然后再将派生出的新行隐藏 最终成果12345678910//以下代码亲测可用，只要浏览器支持伪元素即可 .text-justify&#123;text-align:justify;text-align-last:justify;&#125;.text-justify:after&#123;display:inline-block;content:'';width:100%;&#125;","categories":[{"name":"css","slug":"css","permalink":"/localhost:4000/categories/css/"}],"tags":[]},{"title":"css3新特性浅谈","slug":"css3新特性浅谈","date":"2016-12-12T01:26:02.000Z","updated":"2018-02-07T15:20:08.984Z","comments":true,"path":"css3新特性浅谈/","link":"","permalink":"/localhost:4000/css3新特性浅谈/","excerpt":"css3区别于css2增加了哪些呢？是否只有圆角是特殊的？当面试官问你是否了解css3呢，希望你能在本文之后能够说出并使用其中一二。","text":"css3区别于css2增加了哪些呢？是否只有圆角是特殊的？当面试官问你是否了解css3呢，希望你能在本文之后能够说出并使用其中一二。 css的发展css3是css样式表的最新版本，与css2单一规范不同，css3对所以的样式进行了分模块处理，而各个模块之间是分开进行，互不影响。 css3新特性 css3选择器，与jq一样，强化了选择器功能，包括了数量、层次、属性选择器 原先通过图片或者脚本实现视觉效果通过样式实现，减少了标签和脚本的使用，降低维护成本 背景：支持背景大小，多背景设置，减少了标签，更加灵活 盒模型：拓展了盒模型的类型，尤其弹性盒模型flex；支持了盒模型的变形，旋转，缩放，扭曲等 实现了多列布局，摆脱了只能浮动多列布局 阴影效果：文本阴影，盒阴影，简单的阴影效果可以跳过设计稿 web字体解决了浏览器无法识别的字体；web font图标，更加灵活的使用图标字体，减少了维护工作 颜色与透明度，支持了多种颜色模式，支持透明度设置 圆角与边框，更加丰富的设计效果实现，去除直角实边的单一效果 过度与动画交互效果，可以设置动画进行简单的交互，提升体验 媒体特性与响应式布局，boot框架就是基于这点建立的栅格系统","categories":[{"name":"css","slug":"css","permalink":"/localhost:4000/categories/css/"}],"tags":[]},{"title":"css之选择器攻略","slug":"css之选择器攻略","date":"2016-12-12T01:26:02.000Z","updated":"2018-02-07T15:20:08.984Z","comments":true,"path":"css之选择器攻略/","link":"","permalink":"/localhost:4000/css之选择器攻略/","excerpt":"引言 ： 很多小伙伴对css选择器表示不屑，觉得很简单没必要学习，其实你究竟了解多少呢？当面试官问你的时候，你能分出哪些是css3新增的选择器，他们兼容如何？又该如何处理呢？","text":"引言 ： 很多小伙伴对css选择器表示不屑，觉得很简单没必要学习，其实你究竟了解多少呢？当面试官问你的时候，你能分出哪些是css3新增的选择器，他们兼容如何？又该如何处理呢？ css3选择器分类 css3选择器在最新的版本中作为一个独立的模块分离了出来，而css选择器有哪些呢？又该如何分类，请看下图。 选择器攻略 基本选择器id,class,*通配符选择器，复合选择器（选择器分组），无兼容问题 层次选择器后代选择器：e f;子选择器 e&gt;f ;相邻兄弟选择器 e+f,只能选择之后的一个；通用兄弟选择器，e~f 之后的所有，卡可以选择多个；后面三个兼容ie7+ 目标伪类选择器e:target 针对连接到的部分，兼容ie9+ 动态伪类：linked,:visited,:active,:hover,:focus 其中active和focus 兼容8+支持 语言伪类:lang(en)可以针对不同语言，兼容ie8+ ui元素状态伪类：checked,:enabled,:disabled ,兼容ie9+ 结构伪类数量最多的一类，：first-child(css2),:last-child(css3),nth-child(n)筛选第几个，nth-last-child,nth-of-type(n),:root,:only-child,:empty ,等，兼容ie9+ 否定伪类：not() 针对性排除，兼容ie9+ 伪元素伪元素在新的规范中为双冒号，为了区别伪类，ie6-8只识别单冒号，写法不同，无兼容问题 属性选择器针对属性，以及属性值筛选，筛选符号为| 筛选出等于val以及以val-开始，^以val开始的，* 包含val,$以val结束，ie7+ 支持 解决方案 汇总选择器的兼容性，慎重使用，比如针对ie8+ ，可以使用的有基本选择器，层次选择器，动态伪类选择器，语言伪类选择器，伪元素，属性选择器；针对ie6 建议只使用基本选择器以及简单的伪类、伪元素、后代选择器；针对现代浏览器，所有选择器可以放心使用。整体建议还是不要为了使用新的选择器而使用，要找到对应的使用场景，多使用基本选择器能避免低版本ie的适配问题。 使用适配的脚本文件，实现让ie6-8ie6-8支持属性选择器，伪类选择器和伪元素。具体的支持情况根据js库来决定 1234&lt;!- -[if (gte IE 6)&amp;(lte IE 8)]&gt;&lt;script type=\"text/javascript\" src=\"selectivizr.js\"&gt;&lt;/script&gt; &lt;noscript&gt;&lt;link rel=\"stylesheet\" href=\"[fallback css]\" /&gt;&lt;/noscript&gt;&lt;![endif]- -&gt; 注意事项 Selectivizr自动检测最佳的JavaScript库，如果你JavaScript库都没有调用，则IE下的伪类是不起作用的。 样式属性必须使用&lt;link&gt;标签，以&lt;style&gt;标签定义的CSS样式是不会被解析的。 由于安全原因，样式文件需以域的形式调用，像是file:是不起作用的。 此效果非动态的。一旦样式被应用就被固定了，DOM改变时不会映射过去的。 如果JavaScript不可以，你可以使用&lt;noscript&gt;标签调用一个用以反馈提示的样式文件。 Selectivizr要想在IE下起作用，需要时标准模式，请检查您的页面头部是否有DTD 。","categories":[{"name":"css","slug":"css","permalink":"/localhost:4000/categories/css/"}],"tags":[{"name":"css选择器","slug":"css选择器","permalink":"/localhost:4000/tags/css选择器/"}]},{"title":"css之盒子模型的理解","slug":"css之盒子模型的理解","date":"2016-12-12T01:26:02.000Z","updated":"2018-02-07T15:20:08.984Z","comments":true,"path":"css之盒子模型的理解/","link":"","permalink":"/localhost:4000/css之盒子模型的理解/","excerpt":"引言 ：也许你觉得盒子模型很简单，尤其在ie6怪异盒模型已经退出历史舞台的时候，但事实上并非如此，怪异盒模型仍然在不断的被前端开发者所青睐。在css3中更是增加了box-sizing这一属性来改变标准盒模型。","text":"引言 ：也许你觉得盒子模型很简单，尤其在ie6怪异盒模型已经退出历史舞台的时候，但事实上并非如此，怪异盒模型仍然在不断的被前端开发者所青睐。在css3中更是增加了box-sizing这一属性来改变标准盒模型。 概念（box-model）盒子模型，就是针对html标签为单位，所定义的一个形象化的展示模型，规定了元素如何处理元素内容、内边距、边框 和 外边距的方式。而整体的页面布局就是不同的盒子堆砌以及嵌套组成。 盒子模型的差别目前存在的盒子分为两种，一种是w3c标准盒子，另外一种是ie6以下的怪异盒子模型。区别这两种盒子之前，看一下盒子模型中外盒和内盒的概念。 w3c标准的盒模型中外盒以及内盒的定义 ： 外盒尺寸计算（元素空间尺寸）Element空间高度 = content height + padding + border + marginElement 空间宽度 = content width + padding + border + margin 内盒尺寸计算（元素大小）Element Height = content height + padding + border （Height为内容高度）Element Width = content width + padding + border （Width为内容宽度） ie传统盒模型：ie6以下，不含ie6版本。外盒尺寸计算（元素空间尺寸）Element空间高度 = content Height + margin (Height包含了元素内容宽度，边框宽度，内距宽度)Element空间宽度 = content Width + margin (Width包含了元素内容宽度、边框宽度、内距宽度) 内盒尺寸计算（元素大小）Element Height = content Height(Height包含了元素内容宽度，边框宽度，内距宽度)Element Width = content Width(Width包含了元素内容宽度、边框宽度、内距宽度) 可以看到 在以上的盒模型中，元素的宽高定义的非常细，两者的外盒模型是一致的，而ie的内盒模型的宽高是包括了w3c中的内盒模型的整体的,而content width=css属性的width. 实际使用 在目前的主流浏览器使用最新的h5文档申明之后，所参考的都是最新的w3c的盒模型，除非客户ie特别是ie6以下版本才是怪异模型。就使用而言，现状是定义的样式宽高只包括了内容的宽高，而实际的宽高则是一个累加值。所以在定义所有元素大小时，如果宽高中有padding以及padding值时需要对应的宽高减去间距或者边框值，而这样的使用是不便于控制的。所以在w3c的官方说明中，是这样建议的： 目前最好的解决方案是回避这个问题。也就是，不要给元素有指定宽度高度的元素添加内边距和边框，而是尝试将内边距或外边距添加到元素的父元素和子元素。 以上的应用也可以在大多数的网站中得到验证，在许多需要内边距或者边框的，尤其内边距的布局中，前端工程师都会多写一层类似于wrapper 的包裹元素用来解决这个问题。 css3 box-sizing 就概念而言，ie的怪异模型是比较好控制和理解的，w3c在认识到这个问题之后，在css3中追加了改变盒模型的属性:box-sizing ，语法如下：box-sizing ： content-box || border-box || inherit中文版说明：http://www.w3help.org/zh-cn/kb/006/在这个属性中，可以控制内盒模型按照何种方式进行显示，如果是content-box是w3c 的标准盒子，如果是border-box是ie 的怪异盒模型处理。特别需要说明的是这个属性现代的浏览器都是支持的，但IE家族只有IE8版本以上才支持，虽然现代浏览器支持box-sizing，但有些浏览器还是需要加上自己的前缀，Mozilla需要加上-moz-，Webkit内核需要加上-webkit-，Presto内核-o-,IE8-ms-，所以box-sizing兼容浏览器时需要加上各自的前缀：12345678910111213141516/*Content box*/Element &#123; -moz-box-sizing: content-box; /*Firefox3.5+*/ -webkit-box-sizing: content-box; /*Safari3.2+*/ -o-box-sizing: content-box; /*Opera9.6*/ -ms-box-sizing: content-box; /*IE8*/ box-sizing: content-box; /*W3C标准(IE9+，Safari5.1+,Chrome10.0+,Opera10.6+都符合box-sizing的w3c标准语法)*/&#125; /*Border box*/Element &#123; -moz-box-sizing: border-box; /*Firefox3.5+*/ -webkit-box-sizing: border-box; /*Safari3.2+*/ -o-box-sizing: border-box; /*Opera9.6*/ -ms-box-sizing: border-box; /*IE8*/ box-sizing: border-box; /*W3C标准(IE9+，Safari5.1+,Chrome10.0+,Opera10.6+都符合box-sizing的w3c标准语法)*/&#125; 总结 在综合分析和深刻理解盒模型之后，我们可以得出这样的结论： 如果用户主题为ie8以上的现代浏览器，那么可以采用ie 的怪异模式来处理所有的盒模型，在boot等主流框架中也是用的这种。（最新，前端开发人员青睐的） 而如果用户中确定有ie6以及ie7时，需要按照w3c的标准建议，对于有padding的固宽固高元素需要多些一层wrapper。（常用经典，但是不方便的） 针对有宽高同时有padding或者边框的，将宽高的数值减去内间距以及边框的。（少用） 个人建议 总结中第二种方案是最稳妥的，也是目前主流网站所采用的方式。但是随着响应式布局以及w3c的不变更新优化，ie的传统模型将不断的会被更好的支持，那时将不用这么麻烦。","categories":[{"name":"css","slug":"css","permalink":"/localhost:4000/categories/css/"}],"tags":[]},{"title":"css之浮动攻略","slug":"css之浮动攻略","date":"2016-12-12T01:26:02.000Z","updated":"2018-02-07T15:20:08.984Z","comments":true,"path":"css之浮动攻略/","link":"","permalink":"/localhost:4000/css之浮动攻略/","excerpt":"引言 ：css中的浮动向来是前端入门必备的知识点，也是在面试中都会提及的点，有些人也可以用简单的overflow:hidden来解决浮动带来的显示问题。但作为一名优秀的前端，必须对浮动做到知根知底。","text":"引言 ：css中的浮动向来是前端入门必备的知识点，也是在面试中都会提及的点，有些人也可以用简单的overflow:hidden来解决浮动带来的显示问题。但作为一名优秀的前端，必须对浮动做到知根知底。 浮动的概念通常为了使块级元素能够水平排列，我们会将需要这样显示的元素设置浮动来实现需要的效果。常用的浮动有左浮动，右浮动，以及none.对应的css 属性为：float:left;right;none. 注意事项 使用浮动的元素必须为块级元素，对于行级元素以及行内块级设置浮动是没有意义的，因为行级和行内块级本来就是水平排列注意浮动的顺序，如果按照左浮动，会按照文档的代码顺序从左到右显示，如果为右浮动，会从右到左，按照自己的设计稿效果，选择正确的浮动方式 使用浮动的块级元素必须设置正确的宽高，如果不设置，块级元素默认为父元素的宽度，即使设置了浮动，视觉效果也是不浮动的。设置正确的宽高后，当同一行放不下最后一个元素时，会放到下一行继续水平排列设置浮动后，会脱离标准的文档流，需要在浮动结束之后，清除浮动 引发问题 父元素盒子模型得不到正确的宽高，导致边框、内边距错误 父元素盒模型不正确导致的相关显示属性，如父元素的背景，根据父元素定位的元素 父元素盒模型不正确导致的父元素之后的元素错位 清除浮动 浮动元素能确认高宽的情况下，对父元素的高宽进行设定 设置父元素overflow:hidden或者auto 设置父元素为浮动，也可以重新获取高度 设置父元素的伪元素来实现 清除浮动全局样式 12345678910.clearfloat:after &#123; display: block; clear: both; content: \"\"; visibility: hidden; height: 0&#125; .clearfloat &#123; zoom: 1&#125; 父元素设置宽度之后，设置display:table 父元素末尾追加br标签 ，内置clear:both 总结综上 ，清除浮动最简单的方式是overflow:hidden（推荐）,最官方的写法是写一个全局的清除浮动样式（可能浏览器支持不好）","categories":[{"name":"css","slug":"css","permalink":"/localhost:4000/categories/css/"}],"tags":[]},{"title":"js-break与continue的深度理解","slug":"js-break与continue的深度理解","date":"2016-12-11T09:28:38.000Z","updated":"2018-02-07T15:20:08.987Z","comments":true,"path":"js-break与continue的深度理解/","link":"","permalink":"/localhost:4000/js-break与continue的深度理解/","excerpt":"如果你还缺乏对break与continue断点跳出循环的正确理解，请复制粘贴以下代码，思考得出答案（代码涉及标签语句的用法，如果不会的请自行百度）。","text":"如果你还缺乏对break与continue断点跳出循环的正确理解，请复制粘贴以下代码，思考得出答案（代码涉及标签语句的用法，如果不会的请自行百度）。 var k1 = 0; startFor: for (i = 0; i &lt; 10; i++) { for (l = 0; l &lt; 10; l++) { if (l == 5) { break; } k1++; } } var k2=0; startFor: for (i = 0; i &lt; 10; i++) { for (l = 0; l &lt; 10; l++) { if (l == 5) { break startFor; } k2++; } } var k3=0; startFor: for (i = 0; i &lt; 10; i++) { for (l = 0; l &lt; 10; l++) { if (l == 5) { continue; } k3++; } } var k4=0; startFor: for (i = 0; i &lt; 10; i++) { for (l = 0; l &lt; 10; l++) { if (l == 5) { continue startFor; } k4++; } } console.log(\"case1 break当前循环：\"+k1);//50 console.log(\"case2 break外面循环：\"+k2);//5 console.log(\"case3 continue当前循环：\"+k3);//90 console.log(\"case4 continue外面循环：\"+k4);//50","categories":[{"name":"js","slug":"js","permalink":"/localhost:4000/categories/js/"}],"tags":[]},{"title":"npm入门","slug":"npm入门","date":"2016-12-09T09:54:52.000Z","updated":"2018-02-07T15:20:08.988Z","comments":true,"path":"npm入门/","link":"","permalink":"/localhost:4000/npm入门/","excerpt":"在nodejs大环境下，npm作为包管理工具风靡一时，作为前端开发者需要知道npm可以实现哪些操作，核心的机制是如何的。","text":"在nodejs大环境下，npm作为包管理工具风靡一时，作为前端开发者需要知道npm可以实现哪些操作，核心的机制是如何的。 快速入手基本了解 npm官网地址 npm的运行环境是nodejs,默认nodejs安装之后就可以执行npm命令,nodejs的安装教程可以站内搜索或者百度搜索。 123456$ npm -v3.10.3#全局安装 ,建议全局安装一次$ npm i -g#依赖安装,根据项目里的模块依赖情况$ npm i --save-dev 模块版本说明^1.0.0 此主版本 1.x.x&gt;=1.0.0~1.0.0 主版本对，并且包括分支小版本 1.1.0&gt;1.0.x&gt;=1.0.0>1.0.0 安装大于某个版本，默认等于版本的。&lt;1.0.0 安装小于某个版本 npm安装某模块 npm也支持检索，但是npm模块太多，建议根据准确的模块名称直接安装。123456#全局安装某模块$ npm i packname -g#全局安装某模块特定版本$ npm i packname@1.0.0 -g#依赖安装某模块$ npm i packname --save-dev 发布与删除模块 npm增加用户,也可以官网注册 1234# 增加用户$ npm adduser# 用户登录 $ npm login 模块要想发布到npm仓库，必须有package.json的包说明文件，其他不做具体要求，可根据自己的需要灵活开发私属模块。建议通过npm init来实现模块包文件初始化。 123456# 模块初始化$ npm init # 发布模块$ npm publish [name]# 删除模块 $ npm unpublish [name] 查看以及更新模块 1234#查看模块详情$ npm info [name]#更新模块 $ npm update [name] 新建模块简易教程 模块示例,发布模块要符合cmd模块规范。可以按照以下 步骤制定js模块。 代码托管地址新建仓库 新建模块文件夹，或者检出仓库地址，文件夹内写主要入口文件index.js 初始化包描述文件，填写基本模块信息 添加许可证，说明文件等次要信息，必要时可以添加说明文档，测试用例等 模块主js文件参考1234567891011#当前模块依赖的模块var re=require(\"m1\");# 模块私有变量var ab=\"\";# 模块私有方法function parse()&#123; #code here&#125;;#确定对外接口的变量 or方法module.exports.ab=ab;module.exports.parse=parse;","categories":[{"name":"npm","slug":"npm","permalink":"/localhost:4000/categories/npm/"}],"tags":[]},{"title":"git入门（2）——分支管理","slug":"git入门(2)","date":"2016-12-08T09:54:52.000Z","updated":"2018-02-07T15:20:08.985Z","comments":true,"path":"git入门(2)/","link":"","permalink":"/localhost:4000/git入门(2)/","excerpt":"相信你通过git入门学习已经可以进行简单的代码提交与更新了，但那只是开始，这一篇文章将重点带领你如何去做分支管理。","text":"相信你通过git入门学习已经可以进行简单的代码提交与更新了，但那只是开始，这一篇文章将重点带领你如何去做分支管理。 查看分支123456#查看本地分支，其中本地当前分支会有*号标记$ git branch#查看远程分支$ git branch -r#查看所有分支$ git branch -a 切换分支1234567891011121314#新建分支（如果本地已有会报错）$ git branch branchname#切换分支：本地没有该分支，远程有，检出远程分支；本地有该分支，直接切换$ git checkout branchname#切换分支：切换到上一个分支$ git checkout -#切换分支：本地以及远程都没有该分支（提示路径错误），需新建本地分支（当前分支为模板）$ git checkout -b branchname#切换分支：本地以及远程都没有该分支（提示路径错误），需新建本地分支并指定分支模板$ git checkout -b branchname copybranch 删除分支12345678#删除本地分支，要求不再本地分支上，$ git branch -d branchname#如果删除不掉（比如提示有未被归并的修改），尝试追加 -f（--force表示强制）$ git branch -d branchname -f#删除远程分支，提供两种方式(1 删除分支 2 推送空内容 等于删除)$ git push origin --delete dev1$ git push origin :dev1 本地分支推送到远程123456#本地分支推送到远程(远程没有该分支,远程新建分支)$ git push --set-upstream origin branchname#默认推送到对应分支$ git push#默认推送到其他分支$ git push origin dev1 合并分支1234#可以合并指定分支到当前分支（本地）$ git merge branchname#可以合并指定分支到当前分支（远程）$ git merge origin/branchname 分支策略如何利用分支？首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 bug分支 软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： 1234#切换master分支$ git checkout master#创建bug分支$ git checkout -b issue-1 修复完成后，切换到master分支，并完成合并，最后删除issue-1分支： 123456#切换到主分支$ git checkout master#合并bug分支$ git merge --no-ff -m \"merged bug fix 1\" issue-1#删除bug分支$ git branch -d issue-1 临时保存(git stash) 当你正在开发一个分支，但是这个分支还未完全开发好，不能提交到dev,需要临时保存。那么需要提交到本地仓库，然后stash之后就可以保存此时的工作空间。也可以通过这个命令迅速找到此时的提交状态版本。123$ git stashSaved working directory and index state WIP on blog: 06e9083 sdHEAD is now at 06e9083 sd 功能分支 我们经常会遇到需要开发新功能，与bug分支策略基本一致，需要建立单独的分支完成功能开发，然后合并，并且删除该分支 首先确定要在哪个分支上开发功能，假定需要在dev1分支上修复，就从dev1创建fea-dept分支： 1234#切换dev1分支$ git checkout dev1#创建fea分支$ git checkout -b fea-dept 修复完成后，切换到dev1分支，并完成合并，最后删除fea-dept分支： 123456#切换到开发分支$ git checkout dev1#合并fea分支$ git merge --no-ff -m \"merged bug fix 1\" fea-dept#删除fea分支$ git branch -d fea-dept 多人协作 如此多的分支种类，该如何处理,可以参考以下建议，具体情况自己灵活使用。 master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。","categories":[{"name":"git","slug":"git","permalink":"/localhost:4000/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"/localhost:4000/tags/git/"}]},{"title":"git入门（3）——tag管理","slug":"git入门(3)-tag管理","date":"2016-12-08T09:54:52.000Z","updated":"2018-02-07T15:20:08.985Z","comments":true,"path":"git入门(3)-tag管理/","link":"","permalink":"/localhost:4000/git入门(3)-tag管理/","excerpt":"如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。比如说，我们想为我们的 w3cschoolcc 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。","text":"如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。比如说，我们想为我们的 w3cschoolcc 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。 查看标签123#列出所有的tag$ git tag#查看远程分支 新增标签1234567# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag,说明版本信息$ git tag -a v1.0 -m [message]# 新建一个tag在指定commit$ git tag [tag] [commit] 切换标签12# 检出特定版本标签$ git checkout [tag] 删除标签12345# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName] 提交标签123456# 提交指定tag$ git push [remote] [tag]$ git push origin v1.2# 提交所有tag$ git push [remote] --tags 查看标签信息*查看标签的具体信息，查看之后crtl+c退出1$ git show [tag] 更多","categories":[{"name":"git","slug":"git","permalink":"/localhost:4000/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"/localhost:4000/tags/git/"}]},{"title":"web开发之变宽与固宽布局实现","slug":"web开发之变宽与固宽布局实现","date":"2016-12-08T01:33:15.000Z","updated":"2018-02-07T15:20:08.988Z","comments":true,"path":"web开发之变宽与固宽布局实现/","link":"","permalink":"/localhost:4000/web开发之变宽与固宽布局实现/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"web开发之兼容处理思路","slug":"web开发之兼容处理思路","date":"2016-12-08T01:32:44.000Z","updated":"2018-02-07T15:20:08.988Z","comments":true,"path":"web开发之兼容处理思路/","link":"","permalink":"/localhost:4000/web开发之兼容处理思路/","excerpt":"也许你正在犹豫前端开发中如何正确面对页面或者项目的兼容问题，希望本文能给你一些有益的提示和帮助。","text":"也许你正在犹豫前端开发中如何正确面对页面或者项目的兼容问题，希望本文能给你一些有益的提示和帮助。 兼容问题的产生如何看待兼容问题解决兼容问题的思路","categories":[{"name":"web","slug":"web","permalink":"/localhost:4000/categories/web/"}],"tags":[{"name":"前端兼容思路","slug":"前端兼容思路","permalink":"/localhost:4000/tags/前端兼容思路/"}]},{"title":"js闭包的理解","slug":"js闭包的理解","date":"2016-12-08T01:32:24.000Z","updated":"2018-02-07T15:20:08.987Z","comments":true,"path":"js闭包的理解/","link":"","permalink":"/localhost:4000/js闭包的理解/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"js变量作用域问题","slug":"js变量作用域问题","date":"2016-12-08T01:32:12.000Z","updated":"2018-02-07T15:20:08.987Z","comments":true,"path":"js变量作用域问题/","link":"","permalink":"/localhost:4000/js变量作用域问题/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"jquery核心思想浅谈","slug":"jquery核心思想浅谈","date":"2016-12-08T01:31:45.000Z","updated":"2018-02-07T15:20:08.986Z","comments":true,"path":"jquery核心思想浅谈/","link":"","permalink":"/localhost:4000/jquery核心思想浅谈/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"js-String对象内置方法解析","slug":"js-String对象内置方法解析","date":"2016-12-08T01:31:24.000Z","updated":"2018-02-07T15:20:08.987Z","comments":true,"path":"js-String对象内置方法解析/","link":"","permalink":"/localhost:4000/js-String对象内置方法解析/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"js对象继承的几种方式","slug":"js对象继承的几种方式","date":"2016-12-08T01:30:54.000Z","updated":"2018-02-07T15:20:08.987Z","comments":true,"path":"js对象继承的几种方式/","link":"","permalink":"/localhost:4000/js对象继承的几种方式/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"a标签属性详解","slug":"a标签属性详解","date":"2016-12-08T01:29:33.000Z","updated":"2018-02-08T07:27:47.114Z","comments":true,"path":"a标签属性详解/","link":"","permalink":"/localhost:4000/a标签属性详解/","excerpt":"面对一个最熟悉最常用的标签，本文给大家回顾一下项目中可能用到的a标签的几个属性以及作用。 订单","text":"面对一个最熟悉最常用的标签，本文给大家回顾一下项目中可能用到的a标签的几个属性以及作用。 订单","categories":[{"name":"html","slug":"html","permalink":"/localhost:4000/categories/html/"}],"tags":[]},{"title":"html之meta标签详解","slug":"html之meta标签详解","date":"2016-12-08T01:28:01.000Z","updated":"2018-02-07T15:20:08.986Z","comments":true,"path":"html之meta标签详解/","link":"","permalink":"/localhost:4000/html之meta标签详解/","excerpt":"相信你已经多少见过html的meta标签，但是对它的认识可能还不够全面，那么我简单为大家整理了下meta标签全部的属性值以及说明。","text":"相信你已经多少见过html的meta标签，但是对它的认识可能还不够全面，那么我简单为大家整理了下meta标签全部的属性值以及说明。 属性meta为标签head中的子标签，包括content（必选，存储值）、name（键名）、http-equiv（键名）、scheme(content格式)四个属性。其中content属性为标记的具体值，必填值；name为把值关联到某个名称，http-equiv是把值关联到http头部；scheme是规定了content 的文本格式。 http-equiv Content-Type 文档类型,对应值为 text-html;charset=utf-8 ;eg: Cache-Control 缓存控制，常见的取值有private、no-cache、max-age、must-revalidate等，默认为private, 1） 打开新窗口 值为private、no-cache、must-revalidate，那么打开新窗口访问时都会重新访问服务器。 而如果指定了max-age值，那么在此值内的时间里就不会重新访问服务器，例如： Cache-control: max-age=5(表示当访问此网页后的5秒内再次访问不会去服务器) 2） 在地址栏回车 值为private或must-revalidate则只有第一次访问时会访问服务器，以后就不再访问。 值为no-cache，那么每次都会访问。 值为max-age，则在过期之前不会重复访问。 3） 按后退按扭 值为private、must-revalidate、max-age，则不会重访问， 值为no-cache，则每次都重复访问 4） 按刷新按扭 无论为何值，都会重复访问 Cache-control值为“no-cache”时，访问此页面不会在Internet临时文件夹留下页面备份。 eg:&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot;/&gt; refresh 刷新页面,取值 5;URL=http://www.baidu.com,前面为跳转的时间（单位s），页面可以为绝对地址也可以为相对页面地址，页面地址不写默认为刷新当前页面。 eg:&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5;URL=http://www.baidu.com&quot;/&gt; X-UA-Compatible 设置ie浏览器的文档的渲染模式，IE=edge,chrome=1.说明 ：这个参数用于解决浏览器的兼容性一致外观问题，可以使ie不同版本的浏览器有一致的外观，如果是edge则是以最新的模式渲染，如果有谷歌按照谷歌渲染。也可以强制按照ie7 8的标准渲染，如IE=7;IE=9 eg：&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; 其他（不常用的不再说明）expires:网页的有效期，超过这个时间，网页作废，很少用,Sunday 26 October 2008 01:00 GMT；eg:&lt;meta http-equiv=&quot;expires&quot; content=&quot;Sunday 26 October 2008 01:00 GMT&quot; /&gt;content-language:网页的编码,语言类型,zh,en等，语言类型地址：点击查看eg: &lt;meta http-equiv=&quot;content-language&quot; content=&quot;zh-CN&quot; /&gt;Pragma 控制禁止从缓存中访问页面&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt; name 用于定义一些关键属性，用处很多。 keyword 关键字 ，用户描述网站的主题eg: &lt;meta name=&quot;keywords&quot; content=&quot;your tags&quot; /&gt; description 网站描述，每个网页都应有一个不超过 150 个字符且能准确反映网页内容的描述标签eg: &lt;meta name=&quot;description&quot; content=&quot;150 words&quot; /&gt; robots 搜索方式，常见值 all：文件将被检索，且页面上的链接可以被查询； none：文件将不被检索，且页面上的链接不可以被查询； index：文件将被检索； follow：页面上的链接可以被查询； noindex：文件将不被检索，但页面上的链接可以被查询； nofollow：文件将不被检索，页面上的链接可以被查询。 eg :&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt; viewport 针对移动设备，控制视图的宽高，width为页面内容的宽度，initial-scale代表初始方法倍数，maximum-scale代表最大放大倍数，minimum-scale=0.5代表最小放大倍数，height：高度（数值 / device-height）（范围从223 到10,000），user-scalable：用户是否可以手动缩 (no,yes)，而为了更好的使用这个scale参数，需要获取当前的缩放倍率，用设备的宽度缩放640设计稿的比率eg：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width; initial-scale=1.0;maximum-scale=1.0; user-scalable=no;&quot;/&gt; format-detection 忽略识别一些特殊内容，如邮箱，电话等，写在一起可能会失效eg:&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt; apple-mobile-web-app-capable 苹果默认的菜单栏，工具栏eg:&lt;meta name=”apple-mobile-web-app-capable” content=”yes” /&gt; 其他 1234567891011121314151617181920&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=\"HandheldFriendly\" content=\"true\"&gt;&lt;!-- 只有在开启WebApp全屏模式时才生效。content的值为default | black | black-translucent 。 --&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\"&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=\"MobileOptimized\" content=\"320\"&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=\"screen-orientation\" content=\"portrait\"&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=\"x5-orientation\" content=\"portrait\"&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=\"full-screen\" content=\"yes\"&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=\"x5-fullscreen\" content=\"true\"&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=\"browsermode\" content=\"application\"&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=\"x5-page-mode\" content=\"app\"&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt;","categories":[{"name":"html","slug":"html","permalink":"/localhost:4000/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"/localhost:4000/tags/html/"}]},{"title":"css编码规范","slug":"css编码规范","date":"2016-12-08T01:27:42.000Z","updated":"2018-02-07T15:20:08.985Z","comments":true,"path":"css编码规范/","link":"","permalink":"/localhost:4000/css编码规范/","excerpt":"本文就css代码规范进行简单的整理，不完善以及不正确之处欢迎大家批评指正。","text":"本文就css代码规范进行简单的整理，不完善以及不正确之处欢迎大家批评指正。 选择器 选择器命名选择器命名，class命名时选择语义化的，不建议使用直接样式效果，比如.red,.fontBold，另外整体的样式文件中命名建议使用统一的规则，或者驼峰式，或者中划线分割，命名注意缩写，避免与id重名，不建议通过1 2 3等序号命名。关于命名规则以及常见类名可以本站搜索相关文章 选择器选择原则基本的选择器中，尽量使用类选择器；复杂选择器中，尽量少使用层次、属性的相关选择器。 样式重用样式重复可以一定程度的避免，用类样式来提炼公共样式，建议多用样式的预处理，比如less。基本使用类选择器实现重用最简单实用。 合理的避免id的使用原因有二：一个是id修饰权重比较高，不容易被class修改重定义；第二个，id一般被用来定义特定模块的。如果该模块是可重用的，或者不具有特殊意义的不建议使用。 筛选出同时具有中间没有任何间隔，与群组选择器，后代选择器区分开 非主流选择器主要包括：伪类选择器，结构选择器，伪元素，属性选择器，语言选择器等。可以本站搜索选择器攻略查看所有的选择器分类以及使用。基于兼容性考虑，建议大家慎用。 选择器层级层级关系确定在3层以内，去除不必要的层级关系，简化dom结构或者样式组件结构。 样式分类 全局样式顾名思义，没有任何限制条件的样式，可以任何位置使用并达到其显示效果。如果可能有样式代码冲突的，建议写在样式组合中最后。定义全局样式的时候，注意样式污染的问题。一般建议用.c-来区分。 布局样式一般用于页面布局，我们经常会把页面布局和模块混合起来，或者根本就不区分。这实际是因为我们对样式理解不够深刻。实际。从视图分析，很多模块在宽高以及整体布局上都是基于整体布局的。而一些整体布局又是可以重用的，所以这部分建议单独分出来，提高开发效率。一般建议用.g-来区分。 模块样式以模块的思维去写样式代码，按照层级关系依次展开样式，保证模块清晰同时使得一些样式名称可复用，比如title,price等。其中模块样式顶级也可以理解为命名空间，模块子样式可以追加模块样式前缀，比如header-nav。模块样式是样式代码中占据比例最多的部分，针对具体样式，希望既能做到针对业务，又能提炼出可复用、耦合度低的优质模块。一般建议用.m-来区分。 组件样式页面中总有一部分常规组件是我们经常用的，定义好他们对我们开发工作有事半功倍的效果。这些组件常见的有，按钮，单选框，多选框，下拉框，时间选择控件等。一般建议用.u-来区分。 功能样式（交互样式）有些页面中的元素是有额外的含义的，涉及到这类样式时，有时有特定的交互，或者功能，或者内容，我们针对这部分定义为功能样式，比如删除，查看详情，增加，搜索，这些在涉及具体功能时追加的效果，我们会写在功能样式中。一般建议用.f-来区分。 皮肤样式任何一个网站或者页面都有其布局思想，在这个整体的布局当中，颜色自然是不可缺少的，针对主色，交互色，响应颜色，配色等，我们都会把这一类归到皮肤样式中。一般建议用.s-来区分。 样式优化 合理利用继承和默认 可继承的样式如果是正确的，不用重写；如果是不对的，纠正； 任何样式都有默认值。或者是继承来的默认值，针对默认值要清楚，决定是否调整 抽离公共样式代码中有超过2个类超过3行以上公用代码，建议抽离公共样式到公共区或者提炼公共样式 复合属性缩写比如font,border,margin,padding,background等 减少层级关系层级关系越多，代码量越大，同时访问越慢 使用高效能的选择器多使用class选择器，css的查询顺序为从右向左，所以最后一个选择器基本决定了你第一次匹配得到的整体数量。 重绘与重排影响标签显示样式的叫重绘；影响标签大小-盒模型，位置关系的称为重排。尽量减少这两种，如果有需要，优先选择用重绘代替重排。 待补充 书写规范 规则完成一组之后换行， 选择器开始语法之前大括号前面加空格。 只有单行样式时放一行，两行以上每行样式一行，每一行添加分号，最后一行也加。 每个样式属性值前添加空格而属性名之后不加空格。 数值为0的不用加单位，数值小于1的前面的0可以省略。 没有边框的时候写border:none 减少使用低性能的选择器，比如标签，*，多层 除了颜色以及字体外，所有的代码小写，如果有引号使用单引号 字体名称请映射成对应的英文名 背景图片请合理使用csssprites，按照模块、业务、页面来划分均可 css背景图片的文件类型，请按照以下原则来保存:如果背景图片有动画，则保存成gif,如果没有动画，也没有半透明效果，则保存成png-8,如果有半透明效果，则保存成png-24 清除浮动采用样式，不使用增加空标签的方式 避免过小的背景图片平铺 减少使用important 待补充… 编写顺序 显示属性display/list-style/position/float/clear 盒子模型width/height/margin/padding/border 背景background 行高 文本属性其他line-height,color/font/text-decoration/text-align/,text-indent/vertical-align/white-space/content,cursor/z-index/zoom css3属性transform/transition/animation/box-shadow/border-radius 链接的样式请严格按照如下顺序添加a:link -&gt; a:visited -&gt; a:hover -&gt; a:active 注释规范注释长度要求：注释中的每一行长度不超过40个汉字，或者80个英文字符 文件顶部注释 12345/** @description: xxxxx中文说明* @author: zhifu.wang* @update: zhifu.wang (2012-10-17 18:32)*/ 模块注释，模块注释必须单独写在一行 1/* module: module1 by zhifu.wang */ 单行注释，单行注释可以写在单独一行，也可以写在行尾 1/* this is a short comment */ 多行注释 :多行注释必须写在单独行内 1234/** this is comment line 1.* this is comment line 2.*/ 特殊注释 :用于标注修改、待办等信息 12/* TODO: xxxx by zhifu.wang 2012-10-18 18:32 *//* BUGFIX: xxxx by zhifu.wang 2012-10-18 18:32 */ 浏览器hack 浏览器的hack ：能少用就少用hack ,浏览器的hack如下，注意按照一定的顺序书写：-webkit-,-moz-,-o-,-ms-,通用的，针对ie不同版本的，归纳如下：1234IE6 _property: valueIE7 +property: valueIE6/7 *property: valueIE6/7/8/9 property: value\\9","categories":[{"name":"css","slug":"css","permalink":"/localhost:4000/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"/localhost:4000/tags/css/"}]},{"title":"html编码规范","slug":"html编码规范","date":"2016-12-08T01:27:31.000Z","updated":"2018-02-07T15:20:08.986Z","comments":true,"path":"html编码规范/","link":"","permalink":"/localhost:4000/html编码规范/","excerpt":"本文为按照个人前端工程化中开发规划的子分之，将就html代码规范部分简单介绍，如果不完整或者不正确的，欢迎大家纠正并交流。","text":"本文为按照个人前端工程化中开发规划的子分之，将就html代码规范部分简单介绍，如果不完整或者不正确的，欢迎大家纠正并交流。 基本规范 使用&lt;!Doctype html&gt; 文档类型声明，h5的最新声明方式&lt;!DOCTYPE html&gt; 设置网页的编码以及文档类型&lt;meta http-equiv =&quot;Content-Type&quot; content =&quot;text/html; charset=utf-8&quot; /&gt; 设置网页的渲染模式，按照最新的模式渲染&lt;meta http-equiv =&quot;X-UA-Compatible&quot; content =&quot;IE=edge,chrome=1&quot;&gt; 如果是移动页面或者使用boot框架，设置meta的读取情况。&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width; initial-scale=1.0;maximum-scale=1.0; user-scalable=no;&quot;/&gt; 网站的相关meta属性需要设置的设置，比如网站关键字，作者，描述，网站图标，请本站搜索meta关键字 js以及css相关文档在head中引入，其中type属性可以省略，默认正确的，link标签的rel属性不可省略。&lt;script src = &quot;js/jquery-1.11.1.min.js&quot; &gt;&lt;/script &gt; &lt;link rel = &quot;stylesheet&quot; href = &quot;css/bootstrap.min.css&quot; &gt; 针对ie引入的文件写入注释语句中，注释条件语法如下，现在只针对ie8以上版本适配，需要的适配文件见有关资源。目前已经收集的兼容文件有兼容h5,媒体查询响应，css3选择器，css3部分属性。 123456789101112131415&lt;!--[if lt IE 9]&gt;&lt;script src=\"//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js\"&gt;&lt;/script&gt;&lt;script src=\"//cdn.bootcss.com/respond.js/1.4.2/respond.min.js\"&gt;&lt;/script&gt;&lt;script src=\"../js/selectivizr.js\"&gt;&lt;/script&gt;&lt;noscript&gt;&lt;link rel=\"stylesheet\" href=\"[fallback css]\" /&gt;&lt;/noscript&gt;&lt;script src=\"../js/PIE.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; # pie 的需要追加绑定脚本 $(function() &#123; if (window.PIE) &#123; $( '.container-fluid' ).each(function () &#123; PIE.attach(this); &#125;); &#125; &#125;); 针对jquery框架，特殊说明，之后的网站必须引用1.11.1以上版本，并且在其他js引入顺序之前。 设置head内title标签属性，设置正确的网页标题。 页面标签内不写脚本以及样式文件，实现网页的三层分离，也避免写style标签样式，避免focu现象。 与dom有关的脚本绑定事件，写在domready之后，即可以加快页面的载入速度，也能避免事件绑定失败。特别注意的是，如果是自定义非绑定事件，写在domready外面。 页面文件，img，css等文件的命名使用英文语义化，使用驼峰式命名，对于特殊含义的使用中划线分割，对于格式以及访问层级的使用.,禁止使用中文，不建议使用拼音。备注：文件名称不宜过长控制在4个单词以内。 待补充… 语法规范 以下规范不分先后 标签以及标签属性小写 可省略的闭合标签不省略，自闭合的标签可不写结束斜线。 嵌套的标签必须被正确的嵌套，嵌套的子元素有一格的缩进 使用语义化的标签，例如header,footer,nav,article,filedset,section等，避免全页使用div布局。 针对img标签，写有合适的alt以及title属性，用于描述图片信息。 对于标题项或者图片等，如果有需要显示的交互内容，建议写title属性，用于提示内容，在新浪以及淘宝等网站的图片以及标题中都有title属性，用于增加页面友好度，需要注意的是如果页面元素本身有交互效果或者弹框，可以省去。 页面有完整的html结构，包括html,head,body标签。 尽可能精简页面结构，标签最大可能性的是用于存放内容的，如果需要特殊样式用css实现，减少无意义的空标签。这个称作页面重构。 格式化规则：每一个块级元素，新增空白行，行级元素写在同一行，同时子元素有两个空格的缩进。需要注意的是，行级元素换行会引起不必要的空白外间距，避免方式有两种，一种就是行级元素写在同一行，另外一种就是父元素设置font-size为0，当然也可以取巧，只把行级元素的开始标签头部写在上一行即可。 html属性值一律建议使用双引号，格式化html的同时，也便于js编写dom结构。（js为单引号） 属性的使用顺序 class id name data- src for type href title alt aria role 布尔型属性 不用赋值，有就是true，没有就是false 有良好的注释规范，针对页面模块有简要的注释，便于维护。单行注释 ；多行注释 待补充… 更多友情链接 w3school官网-html w3chtml教程 极客学院html视频教程","categories":[{"name":"html","slug":"html","permalink":"/localhost:4000/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"/localhost:4000/tags/html/"}]},{"title":"bower使用入门（一）","slug":"bower入门","date":"2016-12-06T01:28:01.000Z","updated":"2018-02-07T15:20:08.983Z","comments":true,"path":"bower入门/","link":"","permalink":"/localhost:4000/bower入门/","excerpt":"npm作为包管理器可以无差别的管理一些js模块，而bower可以从另一个维度申请下载项目所需的资源，以前端资源的方式去下载并应用到项目当中。","text":"npm作为包管理器可以无差别的管理一些js模块，而bower可以从另一个维度申请下载项目所需的资源，以前端资源的方式去下载并应用到项目当中。 快速入手 bower官网 优点：项目依赖安装，可以固定资源文件，可以支持缓存安装等 全局安装bower 1$ npm install -g bower 项目依赖安装 1$ npm install --save-dev bower 本地资源资源依赖配置初始化 1$ bower init 资源加载,默认安装在bower_components 12345678#项目安装指定资源$ bower install [name] --save-dev#项目安装依赖资源 $ bower install --save-dev#查看资源详情 $ bower info [name]#搜索资源 $ bower search [name] bower支持的安装方式(后面几种是比较建议的方式) #registered package 包名$ bower install jquery#GitHub shorthand（github的短地址）$ bower install desandro/masonry#Git endpoint git的地址$ bower install git://github.com/user/package.git#URL，支持css js taz zip$ bower install http://example.com/script.js#local，本地资源目录 ,更喜欢本地文件的可以用这个，也可以参考bower的缓存文件目录（以文件夹的方式引入到comp中,文件夹理解为一个资源）$ bower install my/local/folder/#local，本地资源目录文件，也可以参考bower的缓存文件目录（以文件夹的方式引入到comp中,文件名为文件夹名，加index）$ bower install my/local/folder/file gulp集成bower bower拓展性很好，支持建立为gulp任务12345678910111213141516//安装资源，可以指定安装之后的目录，可以指定资源集合var bower=require(\"bower\");gulp.task(\"gulpbower\",function()&#123; return bower(&#123; directory: './my_bower_components', cwd: './app' &#125;) .pipe(gulp.dest(\"lib\"));&#125;)//获取资源的主文件var mainBowerFiles=require(\"main-bower-files\");//吧下载的前端模块的主文件加载到lib当中 ,如何配置获取压缩版本的主文件？只获取主文件，不同项目需要的文件可以手动配置gulp.task(\"bowerfiles\",function()&#123; return gulp.src(mainBowerFiles(&#123; paths:\"\", group:\"basic\" &#125;)) .pipe(gulp.dest(\"lib\"));&#125;) 发布与删除资源123456789101112# 发布资源$ bower register &lt;my-package-name&gt; &lt;git-endpoint&gt;# for example$ bower register example git://github.com/user/example.git# 删除资源 ,删除资源需要登录（github），需要你是这个资源的owner# cmd窗口操作bower login? Username csnikey? Password ********bower EAUTH Logged in as csnikey$ bower unregister &lt;my-package-name&gt; bower Package unregistered zj-boot 资源使用资源发布之后如何使用取决于用户，我们推荐你用bower and 其他工具一起使用，比如grunt \\gulp\\requirejs 等，为此可以查看官方使用的api文档","categories":[{"name":"npm","slug":"npm","permalink":"/localhost:4000/categories/npm/"}],"tags":[{"name":"bower","slug":"bower","permalink":"/localhost:4000/tags/bower/"}]}]}